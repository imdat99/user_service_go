// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"app/pkg/database/ent/activitylog"
	"app/pkg/database/ent/apikey"
	"app/pkg/database/ent/notificationsetting"
	"app/pkg/database/ent/paymentmethod"
	"app/pkg/database/ent/predicate"
	"app/pkg/database/ent/privacysetting"
	"app/pkg/database/ent/transaction"
	"app/pkg/database/ent/user"
	"app/pkg/database/ent/user2fa"
	"app/pkg/database/ent/userprofile"
	"app/pkg/database/ent/usersession"
	"app/pkg/database/ent/usertoken"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivityLog         = "ActivityLog"
	TypeApiKey              = "ApiKey"
	TypeNotificationSetting = "NotificationSetting"
	TypePaymentMethod       = "PaymentMethod"
	TypePrivacySetting      = "PrivacySetting"
	TypeTransaction         = "Transaction"
	TypeUser                = "User"
	TypeUser2fa             = "User2fa"
	TypeUserProfile         = "UserProfile"
	TypeUserSession         = "UserSession"
	TypeUserToken           = "UserToken"
)

// ActivityLogMutation represents an operation that mutates the ActivityLog nodes in the graph.
type ActivityLogMutation struct {
	config
	op             Op
	typ            string
	id             *string
	activity_type  *activitylog.ActivityType
	description    *string
	ip_address     *string
	user_agent     *string
	metadata       *json.RawMessage
	appendmetadata json.RawMessage
	created_at     *time.Time
	clearedFields  map[string]struct{}
	user           *string
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*ActivityLog, error)
	predicates     []predicate.ActivityLog
}

var _ ent.Mutation = (*ActivityLogMutation)(nil)

// activitylogOption allows management of the mutation configuration using functional options.
type activitylogOption func(*ActivityLogMutation)

// newActivityLogMutation creates new mutation for the ActivityLog entity.
func newActivityLogMutation(c config, op Op, opts ...activitylogOption) *ActivityLogMutation {
	m := &ActivityLogMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityLogID sets the ID field of the mutation.
func withActivityLogID(id string) activitylogOption {
	return func(m *ActivityLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityLog
		)
		m.oldValue = func(ctx context.Context) (*ActivityLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityLog sets the old ActivityLog of the mutation.
func withActivityLog(node *ActivityLog) activitylogOption {
	return func(m *ActivityLogMutation) {
		m.oldValue = func(context.Context) (*ActivityLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActivityLog entities.
func (m *ActivityLogMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityLogMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityLogMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ActivityLogMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ActivityLogMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ActivityLogMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[activitylog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ActivityLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ActivityLogMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, activitylog.FieldUserID)
}

// SetActivityType sets the "activity_type" field.
func (m *ActivityLogMutation) SetActivityType(at activitylog.ActivityType) {
	m.activity_type = &at
}

// ActivityType returns the value of the "activity_type" field in the mutation.
func (m *ActivityLogMutation) ActivityType() (r activitylog.ActivityType, exists bool) {
	v := m.activity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityType returns the old "activity_type" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldActivityType(ctx context.Context) (v activitylog.ActivityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityType: %w", err)
	}
	return oldValue.ActivityType, nil
}

// ResetActivityType resets all changes to the "activity_type" field.
func (m *ActivityLogMutation) ResetActivityType() {
	m.activity_type = nil
}

// SetDescription sets the "description" field.
func (m *ActivityLogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ActivityLogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ActivityLogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[activitylog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ActivityLogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ActivityLogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, activitylog.FieldDescription)
}

// SetIPAddress sets the "ip_address" field.
func (m *ActivityLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *ActivityLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *ActivityLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[activitylog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *ActivityLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *ActivityLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, activitylog.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *ActivityLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *ActivityLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *ActivityLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[activitylog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *ActivityLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *ActivityLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, activitylog.FieldUserAgent)
}

// SetMetadata sets the "metadata" field.
func (m *ActivityLogMutation) SetMetadata(jm json.RawMessage) {
	m.metadata = &jm
	m.appendmetadata = nil
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ActivityLogMutation) Metadata() (r json.RawMessage, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldMetadata(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// AppendMetadata adds jm to the "metadata" field.
func (m *ActivityLogMutation) AppendMetadata(jm json.RawMessage) {
	m.appendmetadata = append(m.appendmetadata, jm...)
}

// AppendedMetadata returns the list of values that were appended to the "metadata" field in this mutation.
func (m *ActivityLogMutation) AppendedMetadata() (json.RawMessage, bool) {
	if len(m.appendmetadata) == 0 {
		return nil, false
	}
	return m.appendmetadata, true
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ActivityLogMutation) ClearMetadata() {
	m.metadata = nil
	m.appendmetadata = nil
	m.clearedFields[activitylog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ActivityLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ActivityLogMutation) ResetMetadata() {
	m.metadata = nil
	m.appendmetadata = nil
	delete(m.clearedFields, activitylog.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ActivityLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[activitylog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ActivityLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, activitylog.FieldCreatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ActivityLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[activitylog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ActivityLogMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ActivityLogMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ActivityLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ActivityLogMutation builder.
func (m *ActivityLogMutation) Where(ps ...predicate.ActivityLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityLog).
func (m *ActivityLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityLogMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, activitylog.FieldUserID)
	}
	if m.activity_type != nil {
		fields = append(fields, activitylog.FieldActivityType)
	}
	if m.description != nil {
		fields = append(fields, activitylog.FieldDescription)
	}
	if m.ip_address != nil {
		fields = append(fields, activitylog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, activitylog.FieldUserAgent)
	}
	if m.metadata != nil {
		fields = append(fields, activitylog.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, activitylog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activitylog.FieldUserID:
		return m.UserID()
	case activitylog.FieldActivityType:
		return m.ActivityType()
	case activitylog.FieldDescription:
		return m.Description()
	case activitylog.FieldIPAddress:
		return m.IPAddress()
	case activitylog.FieldUserAgent:
		return m.UserAgent()
	case activitylog.FieldMetadata:
		return m.Metadata()
	case activitylog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activitylog.FieldUserID:
		return m.OldUserID(ctx)
	case activitylog.FieldActivityType:
		return m.OldActivityType(ctx)
	case activitylog.FieldDescription:
		return m.OldDescription(ctx)
	case activitylog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case activitylog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case activitylog.FieldMetadata:
		return m.OldMetadata(ctx)
	case activitylog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activitylog.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case activitylog.FieldActivityType:
		v, ok := value.(activitylog.ActivityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityType(v)
		return nil
	case activitylog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case activitylog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case activitylog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case activitylog.FieldMetadata:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case activitylog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activitylog.FieldUserID) {
		fields = append(fields, activitylog.FieldUserID)
	}
	if m.FieldCleared(activitylog.FieldDescription) {
		fields = append(fields, activitylog.FieldDescription)
	}
	if m.FieldCleared(activitylog.FieldIPAddress) {
		fields = append(fields, activitylog.FieldIPAddress)
	}
	if m.FieldCleared(activitylog.FieldUserAgent) {
		fields = append(fields, activitylog.FieldUserAgent)
	}
	if m.FieldCleared(activitylog.FieldMetadata) {
		fields = append(fields, activitylog.FieldMetadata)
	}
	if m.FieldCleared(activitylog.FieldCreatedAt) {
		fields = append(fields, activitylog.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityLogMutation) ClearField(name string) error {
	switch name {
	case activitylog.FieldUserID:
		m.ClearUserID()
		return nil
	case activitylog.FieldDescription:
		m.ClearDescription()
		return nil
	case activitylog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case activitylog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case activitylog.FieldMetadata:
		m.ClearMetadata()
		return nil
	case activitylog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityLogMutation) ResetField(name string) error {
	switch name {
	case activitylog.FieldUserID:
		m.ResetUserID()
		return nil
	case activitylog.FieldActivityType:
		m.ResetActivityType()
		return nil
	case activitylog.FieldDescription:
		m.ResetDescription()
		return nil
	case activitylog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case activitylog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case activitylog.FieldMetadata:
		m.ResetMetadata()
		return nil
	case activitylog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, activitylog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activitylog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, activitylog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityLogMutation) EdgeCleared(name string) bool {
	switch name {
	case activitylog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityLogMutation) ClearEdge(name string) error {
	switch name {
	case activitylog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ActivityLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityLogMutation) ResetEdge(name string) error {
	switch name {
	case activitylog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ActivityLog edge %s", name)
}

// ApiKeyMutation represents an operation that mutates the ApiKey nodes in the graph.
type ApiKeyMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	key_name                 *string
	api_key_hash             *string
	api_key_prefix           *string
	permissions              *json.RawMessage
	appendpermissions        json.RawMessage
	rate_limit_per_minute    *int32
	addrate_limit_per_minute *int32
	is_active                *bool
	last_used_at             *time.Time
	expires_at               *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	user                     *string
	cleareduser              bool
	done                     bool
	oldValue                 func(context.Context) (*ApiKey, error)
	predicates               []predicate.ApiKey
}

var _ ent.Mutation = (*ApiKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*ApiKeyMutation)

// newApiKeyMutation creates new mutation for the ApiKey entity.
func newApiKeyMutation(c config, op Op, opts ...apikeyOption) *ApiKeyMutation {
	m := &ApiKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeApiKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiKeyID sets the ID field of the mutation.
func withApiKeyID(id string) apikeyOption {
	return func(m *ApiKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiKey
		)
		m.oldValue = func(ctx context.Context) (*ApiKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiKey sets the old ApiKey of the mutation.
func withApiKey(node *ApiKey) apikeyOption {
	return func(m *ApiKeyMutation) {
		m.oldValue = func(context.Context) (*ApiKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiKey entities.
func (m *ApiKeyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiKeyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiKeyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ApiKeyMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApiKeyMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ApiKeyMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ApiKeyMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[apikey.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApiKeyMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, apikey.FieldUserID)
}

// SetKeyName sets the "key_name" field.
func (m *ApiKeyMutation) SetKeyName(s string) {
	m.key_name = &s
}

// KeyName returns the value of the "key_name" field in the mutation.
func (m *ApiKeyMutation) KeyName() (r string, exists bool) {
	v := m.key_name
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyName returns the old "key_name" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldKeyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyName: %w", err)
	}
	return oldValue.KeyName, nil
}

// ResetKeyName resets all changes to the "key_name" field.
func (m *ApiKeyMutation) ResetKeyName() {
	m.key_name = nil
}

// SetAPIKeyHash sets the "api_key_hash" field.
func (m *ApiKeyMutation) SetAPIKeyHash(s string) {
	m.api_key_hash = &s
}

// APIKeyHash returns the value of the "api_key_hash" field in the mutation.
func (m *ApiKeyMutation) APIKeyHash() (r string, exists bool) {
	v := m.api_key_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKeyHash returns the old "api_key_hash" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldAPIKeyHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKeyHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKeyHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKeyHash: %w", err)
	}
	return oldValue.APIKeyHash, nil
}

// ResetAPIKeyHash resets all changes to the "api_key_hash" field.
func (m *ApiKeyMutation) ResetAPIKeyHash() {
	m.api_key_hash = nil
}

// SetAPIKeyPrefix sets the "api_key_prefix" field.
func (m *ApiKeyMutation) SetAPIKeyPrefix(s string) {
	m.api_key_prefix = &s
}

// APIKeyPrefix returns the value of the "api_key_prefix" field in the mutation.
func (m *ApiKeyMutation) APIKeyPrefix() (r string, exists bool) {
	v := m.api_key_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKeyPrefix returns the old "api_key_prefix" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldAPIKeyPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKeyPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKeyPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKeyPrefix: %w", err)
	}
	return oldValue.APIKeyPrefix, nil
}

// ResetAPIKeyPrefix resets all changes to the "api_key_prefix" field.
func (m *ApiKeyMutation) ResetAPIKeyPrefix() {
	m.api_key_prefix = nil
}

// SetPermissions sets the "permissions" field.
func (m *ApiKeyMutation) SetPermissions(jm json.RawMessage) {
	m.permissions = &jm
	m.appendpermissions = nil
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *ApiKeyMutation) Permissions() (r json.RawMessage, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldPermissions(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// AppendPermissions adds jm to the "permissions" field.
func (m *ApiKeyMutation) AppendPermissions(jm json.RawMessage) {
	m.appendpermissions = append(m.appendpermissions, jm...)
}

// AppendedPermissions returns the list of values that were appended to the "permissions" field in this mutation.
func (m *ApiKeyMutation) AppendedPermissions() (json.RawMessage, bool) {
	if len(m.appendpermissions) == 0 {
		return nil, false
	}
	return m.appendpermissions, true
}

// ClearPermissions clears the value of the "permissions" field.
func (m *ApiKeyMutation) ClearPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	m.clearedFields[apikey.FieldPermissions] = struct{}{}
}

// PermissionsCleared returns if the "permissions" field was cleared in this mutation.
func (m *ApiKeyMutation) PermissionsCleared() bool {
	_, ok := m.clearedFields[apikey.FieldPermissions]
	return ok
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *ApiKeyMutation) ResetPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	delete(m.clearedFields, apikey.FieldPermissions)
}

// SetRateLimitPerMinute sets the "rate_limit_per_minute" field.
func (m *ApiKeyMutation) SetRateLimitPerMinute(i int32) {
	m.rate_limit_per_minute = &i
	m.addrate_limit_per_minute = nil
}

// RateLimitPerMinute returns the value of the "rate_limit_per_minute" field in the mutation.
func (m *ApiKeyMutation) RateLimitPerMinute() (r int32, exists bool) {
	v := m.rate_limit_per_minute
	if v == nil {
		return
	}
	return *v, true
}

// OldRateLimitPerMinute returns the old "rate_limit_per_minute" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldRateLimitPerMinute(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateLimitPerMinute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateLimitPerMinute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateLimitPerMinute: %w", err)
	}
	return oldValue.RateLimitPerMinute, nil
}

// AddRateLimitPerMinute adds i to the "rate_limit_per_minute" field.
func (m *ApiKeyMutation) AddRateLimitPerMinute(i int32) {
	if m.addrate_limit_per_minute != nil {
		*m.addrate_limit_per_minute += i
	} else {
		m.addrate_limit_per_minute = &i
	}
}

// AddedRateLimitPerMinute returns the value that was added to the "rate_limit_per_minute" field in this mutation.
func (m *ApiKeyMutation) AddedRateLimitPerMinute() (r int32, exists bool) {
	v := m.addrate_limit_per_minute
	if v == nil {
		return
	}
	return *v, true
}

// ClearRateLimitPerMinute clears the value of the "rate_limit_per_minute" field.
func (m *ApiKeyMutation) ClearRateLimitPerMinute() {
	m.rate_limit_per_minute = nil
	m.addrate_limit_per_minute = nil
	m.clearedFields[apikey.FieldRateLimitPerMinute] = struct{}{}
}

// RateLimitPerMinuteCleared returns if the "rate_limit_per_minute" field was cleared in this mutation.
func (m *ApiKeyMutation) RateLimitPerMinuteCleared() bool {
	_, ok := m.clearedFields[apikey.FieldRateLimitPerMinute]
	return ok
}

// ResetRateLimitPerMinute resets all changes to the "rate_limit_per_minute" field.
func (m *ApiKeyMutation) ResetRateLimitPerMinute() {
	m.rate_limit_per_minute = nil
	m.addrate_limit_per_minute = nil
	delete(m.clearedFields, apikey.FieldRateLimitPerMinute)
}

// SetIsActive sets the "is_active" field.
func (m *ApiKeyMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ApiKeyMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ClearIsActive clears the value of the "is_active" field.
func (m *ApiKeyMutation) ClearIsActive() {
	m.is_active = nil
	m.clearedFields[apikey.FieldIsActive] = struct{}{}
}

// IsActiveCleared returns if the "is_active" field was cleared in this mutation.
func (m *ApiKeyMutation) IsActiveCleared() bool {
	_, ok := m.clearedFields[apikey.FieldIsActive]
	return ok
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ApiKeyMutation) ResetIsActive() {
	m.is_active = nil
	delete(m.clearedFields, apikey.FieldIsActive)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *ApiKeyMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *ApiKeyMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *ApiKeyMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[apikey.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *ApiKeyMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *ApiKeyMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, apikey.FieldLastUsedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ApiKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ApiKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ApiKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ApiKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ApiKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apikey.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ApiKeyMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[apikey.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ApiKeyMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiKeyMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, apikey.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApiKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApiKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ApiKeyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[apikey.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ApiKeyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApiKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, apikey.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApiKeyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApiKeyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ApiKeyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[apikey.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ApiKeyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApiKeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, apikey.FieldDeletedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApiKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApiKeyMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApiKeyMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApiKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ApiKeyMutation builder.
func (m *ApiKeyMutation) Where(ps ...predicate.ApiKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiKey).
func (m *ApiKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiKeyMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.key_name != nil {
		fields = append(fields, apikey.FieldKeyName)
	}
	if m.api_key_hash != nil {
		fields = append(fields, apikey.FieldAPIKeyHash)
	}
	if m.api_key_prefix != nil {
		fields = append(fields, apikey.FieldAPIKeyPrefix)
	}
	if m.permissions != nil {
		fields = append(fields, apikey.FieldPermissions)
	}
	if m.rate_limit_per_minute != nil {
		fields = append(fields, apikey.FieldRateLimitPerMinute)
	}
	if m.is_active != nil {
		fields = append(fields, apikey.FieldIsActive)
	}
	if m.last_used_at != nil {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldKeyName:
		return m.KeyName()
	case apikey.FieldAPIKeyHash:
		return m.APIKeyHash()
	case apikey.FieldAPIKeyPrefix:
		return m.APIKeyPrefix()
	case apikey.FieldPermissions:
		return m.Permissions()
	case apikey.FieldRateLimitPerMinute:
		return m.RateLimitPerMinute()
	case apikey.FieldIsActive:
		return m.IsActive()
	case apikey.FieldLastUsedAt:
		return m.LastUsedAt()
	case apikey.FieldExpiresAt:
		return m.ExpiresAt()
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldKeyName:
		return m.OldKeyName(ctx)
	case apikey.FieldAPIKeyHash:
		return m.OldAPIKeyHash(ctx)
	case apikey.FieldAPIKeyPrefix:
		return m.OldAPIKeyPrefix(ctx)
	case apikey.FieldPermissions:
		return m.OldPermissions(ctx)
	case apikey.FieldRateLimitPerMinute:
		return m.OldRateLimitPerMinute(ctx)
	case apikey.FieldIsActive:
		return m.OldIsActive(ctx)
	case apikey.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case apikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ApiKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldKeyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyName(v)
		return nil
	case apikey.FieldAPIKeyHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKeyHash(v)
		return nil
	case apikey.FieldAPIKeyPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKeyPrefix(v)
		return nil
	case apikey.FieldPermissions:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case apikey.FieldRateLimitPerMinute:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateLimitPerMinute(v)
		return nil
	case apikey.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case apikey.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case apikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ApiKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiKeyMutation) AddedFields() []string {
	var fields []string
	if m.addrate_limit_per_minute != nil {
		fields = append(fields, apikey.FieldRateLimitPerMinute)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldRateLimitPerMinute:
		return m.AddedRateLimitPerMinute()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldRateLimitPerMinute:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRateLimitPerMinute(v)
		return nil
	}
	return fmt.Errorf("unknown ApiKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldUserID) {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.FieldCleared(apikey.FieldPermissions) {
		fields = append(fields, apikey.FieldPermissions)
	}
	if m.FieldCleared(apikey.FieldRateLimitPerMinute) {
		fields = append(fields, apikey.FieldRateLimitPerMinute)
	}
	if m.FieldCleared(apikey.FieldIsActive) {
		fields = append(fields, apikey.FieldIsActive)
	}
	if m.FieldCleared(apikey.FieldLastUsedAt) {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.FieldCleared(apikey.FieldExpiresAt) {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.FieldCleared(apikey.FieldCreatedAt) {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.FieldCleared(apikey.FieldUpdatedAt) {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.FieldCleared(apikey.FieldDeletedAt) {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldUserID:
		m.ClearUserID()
		return nil
	case apikey.FieldPermissions:
		m.ClearPermissions()
		return nil
	case apikey.FieldRateLimitPerMinute:
		m.ClearRateLimitPerMinute()
		return nil
	case apikey.FieldIsActive:
		m.ClearIsActive()
		return nil
	case apikey.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case apikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case apikey.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case apikey.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ApiKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldKeyName:
		m.ResetKeyName()
		return nil
	case apikey.FieldAPIKeyHash:
		m.ResetAPIKeyHash()
		return nil
	case apikey.FieldAPIKeyPrefix:
		m.ResetAPIKeyPrefix()
		return nil
	case apikey.FieldPermissions:
		m.ResetPermissions()
		return nil
	case apikey.FieldRateLimitPerMinute:
		m.ResetRateLimitPerMinute()
		return nil
	case apikey.FieldIsActive:
		m.ResetIsActive()
		return nil
	case apikey.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case apikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ApiKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ApiKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ApiKey edge %s", name)
}

// NotificationSettingMutation represents an operation that mutates the NotificationSetting nodes in the graph.
type NotificationSettingMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	email_notifications   *bool
	sms_notifications     *bool
	push_notifications    *bool
	marketing_emails      *bool
	security_alerts       *bool
	login_alerts          *bool
	profile_updates       *bool
	payment_notifications *bool
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *string
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*NotificationSetting, error)
	predicates            []predicate.NotificationSetting
}

var _ ent.Mutation = (*NotificationSettingMutation)(nil)

// notificationsettingOption allows management of the mutation configuration using functional options.
type notificationsettingOption func(*NotificationSettingMutation)

// newNotificationSettingMutation creates new mutation for the NotificationSetting entity.
func newNotificationSettingMutation(c config, op Op, opts ...notificationsettingOption) *NotificationSettingMutation {
	m := &NotificationSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationSettingID sets the ID field of the mutation.
func withNotificationSettingID(id string) notificationsettingOption {
	return func(m *NotificationSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationSetting
		)
		m.oldValue = func(ctx context.Context) (*NotificationSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationSetting sets the old NotificationSetting of the mutation.
func withNotificationSetting(node *NotificationSetting) notificationsettingOption {
	return func(m *NotificationSettingMutation) {
		m.oldValue = func(context.Context) (*NotificationSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationSetting entities.
func (m *NotificationSettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationSettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationSettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *NotificationSettingMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NotificationSettingMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *NotificationSettingMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[notificationsetting.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *NotificationSettingMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NotificationSettingMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, notificationsetting.FieldUserID)
}

// SetEmailNotifications sets the "email_notifications" field.
func (m *NotificationSettingMutation) SetEmailNotifications(b bool) {
	m.email_notifications = &b
}

// EmailNotifications returns the value of the "email_notifications" field in the mutation.
func (m *NotificationSettingMutation) EmailNotifications() (r bool, exists bool) {
	v := m.email_notifications
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailNotifications returns the old "email_notifications" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldEmailNotifications(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailNotifications is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailNotifications requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailNotifications: %w", err)
	}
	return oldValue.EmailNotifications, nil
}

// ClearEmailNotifications clears the value of the "email_notifications" field.
func (m *NotificationSettingMutation) ClearEmailNotifications() {
	m.email_notifications = nil
	m.clearedFields[notificationsetting.FieldEmailNotifications] = struct{}{}
}

// EmailNotificationsCleared returns if the "email_notifications" field was cleared in this mutation.
func (m *NotificationSettingMutation) EmailNotificationsCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldEmailNotifications]
	return ok
}

// ResetEmailNotifications resets all changes to the "email_notifications" field.
func (m *NotificationSettingMutation) ResetEmailNotifications() {
	m.email_notifications = nil
	delete(m.clearedFields, notificationsetting.FieldEmailNotifications)
}

// SetSmsNotifications sets the "sms_notifications" field.
func (m *NotificationSettingMutation) SetSmsNotifications(b bool) {
	m.sms_notifications = &b
}

// SmsNotifications returns the value of the "sms_notifications" field in the mutation.
func (m *NotificationSettingMutation) SmsNotifications() (r bool, exists bool) {
	v := m.sms_notifications
	if v == nil {
		return
	}
	return *v, true
}

// OldSmsNotifications returns the old "sms_notifications" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldSmsNotifications(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSmsNotifications is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSmsNotifications requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmsNotifications: %w", err)
	}
	return oldValue.SmsNotifications, nil
}

// ClearSmsNotifications clears the value of the "sms_notifications" field.
func (m *NotificationSettingMutation) ClearSmsNotifications() {
	m.sms_notifications = nil
	m.clearedFields[notificationsetting.FieldSmsNotifications] = struct{}{}
}

// SmsNotificationsCleared returns if the "sms_notifications" field was cleared in this mutation.
func (m *NotificationSettingMutation) SmsNotificationsCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldSmsNotifications]
	return ok
}

// ResetSmsNotifications resets all changes to the "sms_notifications" field.
func (m *NotificationSettingMutation) ResetSmsNotifications() {
	m.sms_notifications = nil
	delete(m.clearedFields, notificationsetting.FieldSmsNotifications)
}

// SetPushNotifications sets the "push_notifications" field.
func (m *NotificationSettingMutation) SetPushNotifications(b bool) {
	m.push_notifications = &b
}

// PushNotifications returns the value of the "push_notifications" field in the mutation.
func (m *NotificationSettingMutation) PushNotifications() (r bool, exists bool) {
	v := m.push_notifications
	if v == nil {
		return
	}
	return *v, true
}

// OldPushNotifications returns the old "push_notifications" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldPushNotifications(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushNotifications is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushNotifications requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushNotifications: %w", err)
	}
	return oldValue.PushNotifications, nil
}

// ClearPushNotifications clears the value of the "push_notifications" field.
func (m *NotificationSettingMutation) ClearPushNotifications() {
	m.push_notifications = nil
	m.clearedFields[notificationsetting.FieldPushNotifications] = struct{}{}
}

// PushNotificationsCleared returns if the "push_notifications" field was cleared in this mutation.
func (m *NotificationSettingMutation) PushNotificationsCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldPushNotifications]
	return ok
}

// ResetPushNotifications resets all changes to the "push_notifications" field.
func (m *NotificationSettingMutation) ResetPushNotifications() {
	m.push_notifications = nil
	delete(m.clearedFields, notificationsetting.FieldPushNotifications)
}

// SetMarketingEmails sets the "marketing_emails" field.
func (m *NotificationSettingMutation) SetMarketingEmails(b bool) {
	m.marketing_emails = &b
}

// MarketingEmails returns the value of the "marketing_emails" field in the mutation.
func (m *NotificationSettingMutation) MarketingEmails() (r bool, exists bool) {
	v := m.marketing_emails
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketingEmails returns the old "marketing_emails" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldMarketingEmails(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketingEmails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketingEmails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketingEmails: %w", err)
	}
	return oldValue.MarketingEmails, nil
}

// ClearMarketingEmails clears the value of the "marketing_emails" field.
func (m *NotificationSettingMutation) ClearMarketingEmails() {
	m.marketing_emails = nil
	m.clearedFields[notificationsetting.FieldMarketingEmails] = struct{}{}
}

// MarketingEmailsCleared returns if the "marketing_emails" field was cleared in this mutation.
func (m *NotificationSettingMutation) MarketingEmailsCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldMarketingEmails]
	return ok
}

// ResetMarketingEmails resets all changes to the "marketing_emails" field.
func (m *NotificationSettingMutation) ResetMarketingEmails() {
	m.marketing_emails = nil
	delete(m.clearedFields, notificationsetting.FieldMarketingEmails)
}

// SetSecurityAlerts sets the "security_alerts" field.
func (m *NotificationSettingMutation) SetSecurityAlerts(b bool) {
	m.security_alerts = &b
}

// SecurityAlerts returns the value of the "security_alerts" field in the mutation.
func (m *NotificationSettingMutation) SecurityAlerts() (r bool, exists bool) {
	v := m.security_alerts
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityAlerts returns the old "security_alerts" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldSecurityAlerts(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecurityAlerts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecurityAlerts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityAlerts: %w", err)
	}
	return oldValue.SecurityAlerts, nil
}

// ClearSecurityAlerts clears the value of the "security_alerts" field.
func (m *NotificationSettingMutation) ClearSecurityAlerts() {
	m.security_alerts = nil
	m.clearedFields[notificationsetting.FieldSecurityAlerts] = struct{}{}
}

// SecurityAlertsCleared returns if the "security_alerts" field was cleared in this mutation.
func (m *NotificationSettingMutation) SecurityAlertsCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldSecurityAlerts]
	return ok
}

// ResetSecurityAlerts resets all changes to the "security_alerts" field.
func (m *NotificationSettingMutation) ResetSecurityAlerts() {
	m.security_alerts = nil
	delete(m.clearedFields, notificationsetting.FieldSecurityAlerts)
}

// SetLoginAlerts sets the "login_alerts" field.
func (m *NotificationSettingMutation) SetLoginAlerts(b bool) {
	m.login_alerts = &b
}

// LoginAlerts returns the value of the "login_alerts" field in the mutation.
func (m *NotificationSettingMutation) LoginAlerts() (r bool, exists bool) {
	v := m.login_alerts
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginAlerts returns the old "login_alerts" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldLoginAlerts(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginAlerts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginAlerts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginAlerts: %w", err)
	}
	return oldValue.LoginAlerts, nil
}

// ClearLoginAlerts clears the value of the "login_alerts" field.
func (m *NotificationSettingMutation) ClearLoginAlerts() {
	m.login_alerts = nil
	m.clearedFields[notificationsetting.FieldLoginAlerts] = struct{}{}
}

// LoginAlertsCleared returns if the "login_alerts" field was cleared in this mutation.
func (m *NotificationSettingMutation) LoginAlertsCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldLoginAlerts]
	return ok
}

// ResetLoginAlerts resets all changes to the "login_alerts" field.
func (m *NotificationSettingMutation) ResetLoginAlerts() {
	m.login_alerts = nil
	delete(m.clearedFields, notificationsetting.FieldLoginAlerts)
}

// SetProfileUpdates sets the "profile_updates" field.
func (m *NotificationSettingMutation) SetProfileUpdates(b bool) {
	m.profile_updates = &b
}

// ProfileUpdates returns the value of the "profile_updates" field in the mutation.
func (m *NotificationSettingMutation) ProfileUpdates() (r bool, exists bool) {
	v := m.profile_updates
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileUpdates returns the old "profile_updates" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldProfileUpdates(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileUpdates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileUpdates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileUpdates: %w", err)
	}
	return oldValue.ProfileUpdates, nil
}

// ClearProfileUpdates clears the value of the "profile_updates" field.
func (m *NotificationSettingMutation) ClearProfileUpdates() {
	m.profile_updates = nil
	m.clearedFields[notificationsetting.FieldProfileUpdates] = struct{}{}
}

// ProfileUpdatesCleared returns if the "profile_updates" field was cleared in this mutation.
func (m *NotificationSettingMutation) ProfileUpdatesCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldProfileUpdates]
	return ok
}

// ResetProfileUpdates resets all changes to the "profile_updates" field.
func (m *NotificationSettingMutation) ResetProfileUpdates() {
	m.profile_updates = nil
	delete(m.clearedFields, notificationsetting.FieldProfileUpdates)
}

// SetPaymentNotifications sets the "payment_notifications" field.
func (m *NotificationSettingMutation) SetPaymentNotifications(b bool) {
	m.payment_notifications = &b
}

// PaymentNotifications returns the value of the "payment_notifications" field in the mutation.
func (m *NotificationSettingMutation) PaymentNotifications() (r bool, exists bool) {
	v := m.payment_notifications
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentNotifications returns the old "payment_notifications" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldPaymentNotifications(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentNotifications is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentNotifications requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentNotifications: %w", err)
	}
	return oldValue.PaymentNotifications, nil
}

// ClearPaymentNotifications clears the value of the "payment_notifications" field.
func (m *NotificationSettingMutation) ClearPaymentNotifications() {
	m.payment_notifications = nil
	m.clearedFields[notificationsetting.FieldPaymentNotifications] = struct{}{}
}

// PaymentNotificationsCleared returns if the "payment_notifications" field was cleared in this mutation.
func (m *NotificationSettingMutation) PaymentNotificationsCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldPaymentNotifications]
	return ok
}

// ResetPaymentNotifications resets all changes to the "payment_notifications" field.
func (m *NotificationSettingMutation) ResetPaymentNotifications() {
	m.payment_notifications = nil
	delete(m.clearedFields, notificationsetting.FieldPaymentNotifications)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *NotificationSettingMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[notificationsetting.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *NotificationSettingMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationSettingMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, notificationsetting.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *NotificationSettingMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[notificationsetting.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *NotificationSettingMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, notificationsetting.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *NotificationSettingMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[notificationsetting.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *NotificationSettingMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NotificationSettingMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NotificationSettingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NotificationSettingMutation builder.
func (m *NotificationSettingMutation) Where(ps ...predicate.NotificationSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationSetting).
func (m *NotificationSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationSettingMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, notificationsetting.FieldUserID)
	}
	if m.email_notifications != nil {
		fields = append(fields, notificationsetting.FieldEmailNotifications)
	}
	if m.sms_notifications != nil {
		fields = append(fields, notificationsetting.FieldSmsNotifications)
	}
	if m.push_notifications != nil {
		fields = append(fields, notificationsetting.FieldPushNotifications)
	}
	if m.marketing_emails != nil {
		fields = append(fields, notificationsetting.FieldMarketingEmails)
	}
	if m.security_alerts != nil {
		fields = append(fields, notificationsetting.FieldSecurityAlerts)
	}
	if m.login_alerts != nil {
		fields = append(fields, notificationsetting.FieldLoginAlerts)
	}
	if m.profile_updates != nil {
		fields = append(fields, notificationsetting.FieldProfileUpdates)
	}
	if m.payment_notifications != nil {
		fields = append(fields, notificationsetting.FieldPaymentNotifications)
	}
	if m.created_at != nil {
		fields = append(fields, notificationsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationsetting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationsetting.FieldUserID:
		return m.UserID()
	case notificationsetting.FieldEmailNotifications:
		return m.EmailNotifications()
	case notificationsetting.FieldSmsNotifications:
		return m.SmsNotifications()
	case notificationsetting.FieldPushNotifications:
		return m.PushNotifications()
	case notificationsetting.FieldMarketingEmails:
		return m.MarketingEmails()
	case notificationsetting.FieldSecurityAlerts:
		return m.SecurityAlerts()
	case notificationsetting.FieldLoginAlerts:
		return m.LoginAlerts()
	case notificationsetting.FieldProfileUpdates:
		return m.ProfileUpdates()
	case notificationsetting.FieldPaymentNotifications:
		return m.PaymentNotifications()
	case notificationsetting.FieldCreatedAt:
		return m.CreatedAt()
	case notificationsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationsetting.FieldUserID:
		return m.OldUserID(ctx)
	case notificationsetting.FieldEmailNotifications:
		return m.OldEmailNotifications(ctx)
	case notificationsetting.FieldSmsNotifications:
		return m.OldSmsNotifications(ctx)
	case notificationsetting.FieldPushNotifications:
		return m.OldPushNotifications(ctx)
	case notificationsetting.FieldMarketingEmails:
		return m.OldMarketingEmails(ctx)
	case notificationsetting.FieldSecurityAlerts:
		return m.OldSecurityAlerts(ctx)
	case notificationsetting.FieldLoginAlerts:
		return m.OldLoginAlerts(ctx)
	case notificationsetting.FieldProfileUpdates:
		return m.OldProfileUpdates(ctx)
	case notificationsetting.FieldPaymentNotifications:
		return m.OldPaymentNotifications(ctx)
	case notificationsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationsetting.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case notificationsetting.FieldEmailNotifications:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailNotifications(v)
		return nil
	case notificationsetting.FieldSmsNotifications:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmsNotifications(v)
		return nil
	case notificationsetting.FieldPushNotifications:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushNotifications(v)
		return nil
	case notificationsetting.FieldMarketingEmails:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketingEmails(v)
		return nil
	case notificationsetting.FieldSecurityAlerts:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityAlerts(v)
		return nil
	case notificationsetting.FieldLoginAlerts:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginAlerts(v)
		return nil
	case notificationsetting.FieldProfileUpdates:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileUpdates(v)
		return nil
	case notificationsetting.FieldPaymentNotifications:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentNotifications(v)
		return nil
	case notificationsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationSettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationSettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationsetting.FieldUserID) {
		fields = append(fields, notificationsetting.FieldUserID)
	}
	if m.FieldCleared(notificationsetting.FieldEmailNotifications) {
		fields = append(fields, notificationsetting.FieldEmailNotifications)
	}
	if m.FieldCleared(notificationsetting.FieldSmsNotifications) {
		fields = append(fields, notificationsetting.FieldSmsNotifications)
	}
	if m.FieldCleared(notificationsetting.FieldPushNotifications) {
		fields = append(fields, notificationsetting.FieldPushNotifications)
	}
	if m.FieldCleared(notificationsetting.FieldMarketingEmails) {
		fields = append(fields, notificationsetting.FieldMarketingEmails)
	}
	if m.FieldCleared(notificationsetting.FieldSecurityAlerts) {
		fields = append(fields, notificationsetting.FieldSecurityAlerts)
	}
	if m.FieldCleared(notificationsetting.FieldLoginAlerts) {
		fields = append(fields, notificationsetting.FieldLoginAlerts)
	}
	if m.FieldCleared(notificationsetting.FieldProfileUpdates) {
		fields = append(fields, notificationsetting.FieldProfileUpdates)
	}
	if m.FieldCleared(notificationsetting.FieldPaymentNotifications) {
		fields = append(fields, notificationsetting.FieldPaymentNotifications)
	}
	if m.FieldCleared(notificationsetting.FieldCreatedAt) {
		fields = append(fields, notificationsetting.FieldCreatedAt)
	}
	if m.FieldCleared(notificationsetting.FieldUpdatedAt) {
		fields = append(fields, notificationsetting.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationSettingMutation) ClearField(name string) error {
	switch name {
	case notificationsetting.FieldUserID:
		m.ClearUserID()
		return nil
	case notificationsetting.FieldEmailNotifications:
		m.ClearEmailNotifications()
		return nil
	case notificationsetting.FieldSmsNotifications:
		m.ClearSmsNotifications()
		return nil
	case notificationsetting.FieldPushNotifications:
		m.ClearPushNotifications()
		return nil
	case notificationsetting.FieldMarketingEmails:
		m.ClearMarketingEmails()
		return nil
	case notificationsetting.FieldSecurityAlerts:
		m.ClearSecurityAlerts()
		return nil
	case notificationsetting.FieldLoginAlerts:
		m.ClearLoginAlerts()
		return nil
	case notificationsetting.FieldProfileUpdates:
		m.ClearProfileUpdates()
		return nil
	case notificationsetting.FieldPaymentNotifications:
		m.ClearPaymentNotifications()
		return nil
	case notificationsetting.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case notificationsetting.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationSettingMutation) ResetField(name string) error {
	switch name {
	case notificationsetting.FieldUserID:
		m.ResetUserID()
		return nil
	case notificationsetting.FieldEmailNotifications:
		m.ResetEmailNotifications()
		return nil
	case notificationsetting.FieldSmsNotifications:
		m.ResetSmsNotifications()
		return nil
	case notificationsetting.FieldPushNotifications:
		m.ResetPushNotifications()
		return nil
	case notificationsetting.FieldMarketingEmails:
		m.ResetMarketingEmails()
		return nil
	case notificationsetting.FieldSecurityAlerts:
		m.ResetSecurityAlerts()
		return nil
	case notificationsetting.FieldLoginAlerts:
		m.ResetLoginAlerts()
		return nil
	case notificationsetting.FieldProfileUpdates:
		m.ResetProfileUpdates()
		return nil
	case notificationsetting.FieldPaymentNotifications:
		m.ResetPaymentNotifications()
		return nil
	case notificationsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, notificationsetting.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationSettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationsetting.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, notificationsetting.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationSettingMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationsetting.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationSettingMutation) ClearEdge(name string) error {
	switch name {
	case notificationsetting.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown NotificationSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationSettingMutation) ResetEdge(name string) error {
	switch name {
	case notificationsetting.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown NotificationSetting edge %s", name)
}

// PaymentMethodMutation represents an operation that mutates the PaymentMethod nodes in the graph.
type PaymentMethodMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	method_type         *paymentmethod.MethodType
	provider            *string
	masked_number       *string
	holder_name         *string
	expiry_month        *int8
	addexpiry_month     *int8
	expiry_year         *int16
	addexpiry_year      *int16
	is_default          *bool
	is_active           *bool
	external_id         *string
	metadata            *json.RawMessage
	appendmetadata      json.RawMessage
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	user                *string
	cleareduser         bool
	transactions        map[string]struct{}
	removedtransactions map[string]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*PaymentMethod, error)
	predicates          []predicate.PaymentMethod
}

var _ ent.Mutation = (*PaymentMethodMutation)(nil)

// paymentmethodOption allows management of the mutation configuration using functional options.
type paymentmethodOption func(*PaymentMethodMutation)

// newPaymentMethodMutation creates new mutation for the PaymentMethod entity.
func newPaymentMethodMutation(c config, op Op, opts ...paymentmethodOption) *PaymentMethodMutation {
	m := &PaymentMethodMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentMethod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentMethodID sets the ID field of the mutation.
func withPaymentMethodID(id string) paymentmethodOption {
	return func(m *PaymentMethodMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentMethod
		)
		m.oldValue = func(ctx context.Context) (*PaymentMethod, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentMethod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentMethod sets the old PaymentMethod of the mutation.
func withPaymentMethod(node *PaymentMethod) paymentmethodOption {
	return func(m *PaymentMethodMutation) {
		m.oldValue = func(context.Context) (*PaymentMethod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMethodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMethodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentMethod entities.
func (m *PaymentMethodMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMethodMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMethodMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentMethod.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PaymentMethodMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PaymentMethodMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *PaymentMethodMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[paymentmethod.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *PaymentMethodMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PaymentMethodMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, paymentmethod.FieldUserID)
}

// SetMethodType sets the "method_type" field.
func (m *PaymentMethodMutation) SetMethodType(pt paymentmethod.MethodType) {
	m.method_type = &pt
}

// MethodType returns the value of the "method_type" field in the mutation.
func (m *PaymentMethodMutation) MethodType() (r paymentmethod.MethodType, exists bool) {
	v := m.method_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodType returns the old "method_type" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldMethodType(ctx context.Context) (v paymentmethod.MethodType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethodType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethodType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodType: %w", err)
	}
	return oldValue.MethodType, nil
}

// ResetMethodType resets all changes to the "method_type" field.
func (m *PaymentMethodMutation) ResetMethodType() {
	m.method_type = nil
}

// SetProvider sets the "provider" field.
func (m *PaymentMethodMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *PaymentMethodMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *PaymentMethodMutation) ResetProvider() {
	m.provider = nil
}

// SetMaskedNumber sets the "masked_number" field.
func (m *PaymentMethodMutation) SetMaskedNumber(s string) {
	m.masked_number = &s
}

// MaskedNumber returns the value of the "masked_number" field in the mutation.
func (m *PaymentMethodMutation) MaskedNumber() (r string, exists bool) {
	v := m.masked_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMaskedNumber returns the old "masked_number" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldMaskedNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaskedNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaskedNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaskedNumber: %w", err)
	}
	return oldValue.MaskedNumber, nil
}

// ClearMaskedNumber clears the value of the "masked_number" field.
func (m *PaymentMethodMutation) ClearMaskedNumber() {
	m.masked_number = nil
	m.clearedFields[paymentmethod.FieldMaskedNumber] = struct{}{}
}

// MaskedNumberCleared returns if the "masked_number" field was cleared in this mutation.
func (m *PaymentMethodMutation) MaskedNumberCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldMaskedNumber]
	return ok
}

// ResetMaskedNumber resets all changes to the "masked_number" field.
func (m *PaymentMethodMutation) ResetMaskedNumber() {
	m.masked_number = nil
	delete(m.clearedFields, paymentmethod.FieldMaskedNumber)
}

// SetHolderName sets the "holder_name" field.
func (m *PaymentMethodMutation) SetHolderName(s string) {
	m.holder_name = &s
}

// HolderName returns the value of the "holder_name" field in the mutation.
func (m *PaymentMethodMutation) HolderName() (r string, exists bool) {
	v := m.holder_name
	if v == nil {
		return
	}
	return *v, true
}

// OldHolderName returns the old "holder_name" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldHolderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHolderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHolderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHolderName: %w", err)
	}
	return oldValue.HolderName, nil
}

// ClearHolderName clears the value of the "holder_name" field.
func (m *PaymentMethodMutation) ClearHolderName() {
	m.holder_name = nil
	m.clearedFields[paymentmethod.FieldHolderName] = struct{}{}
}

// HolderNameCleared returns if the "holder_name" field was cleared in this mutation.
func (m *PaymentMethodMutation) HolderNameCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldHolderName]
	return ok
}

// ResetHolderName resets all changes to the "holder_name" field.
func (m *PaymentMethodMutation) ResetHolderName() {
	m.holder_name = nil
	delete(m.clearedFields, paymentmethod.FieldHolderName)
}

// SetExpiryMonth sets the "expiry_month" field.
func (m *PaymentMethodMutation) SetExpiryMonth(i int8) {
	m.expiry_month = &i
	m.addexpiry_month = nil
}

// ExpiryMonth returns the value of the "expiry_month" field in the mutation.
func (m *PaymentMethodMutation) ExpiryMonth() (r int8, exists bool) {
	v := m.expiry_month
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryMonth returns the old "expiry_month" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldExpiryMonth(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryMonth: %w", err)
	}
	return oldValue.ExpiryMonth, nil
}

// AddExpiryMonth adds i to the "expiry_month" field.
func (m *PaymentMethodMutation) AddExpiryMonth(i int8) {
	if m.addexpiry_month != nil {
		*m.addexpiry_month += i
	} else {
		m.addexpiry_month = &i
	}
}

// AddedExpiryMonth returns the value that was added to the "expiry_month" field in this mutation.
func (m *PaymentMethodMutation) AddedExpiryMonth() (r int8, exists bool) {
	v := m.addexpiry_month
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpiryMonth clears the value of the "expiry_month" field.
func (m *PaymentMethodMutation) ClearExpiryMonth() {
	m.expiry_month = nil
	m.addexpiry_month = nil
	m.clearedFields[paymentmethod.FieldExpiryMonth] = struct{}{}
}

// ExpiryMonthCleared returns if the "expiry_month" field was cleared in this mutation.
func (m *PaymentMethodMutation) ExpiryMonthCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldExpiryMonth]
	return ok
}

// ResetExpiryMonth resets all changes to the "expiry_month" field.
func (m *PaymentMethodMutation) ResetExpiryMonth() {
	m.expiry_month = nil
	m.addexpiry_month = nil
	delete(m.clearedFields, paymentmethod.FieldExpiryMonth)
}

// SetExpiryYear sets the "expiry_year" field.
func (m *PaymentMethodMutation) SetExpiryYear(i int16) {
	m.expiry_year = &i
	m.addexpiry_year = nil
}

// ExpiryYear returns the value of the "expiry_year" field in the mutation.
func (m *PaymentMethodMutation) ExpiryYear() (r int16, exists bool) {
	v := m.expiry_year
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryYear returns the old "expiry_year" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldExpiryYear(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryYear: %w", err)
	}
	return oldValue.ExpiryYear, nil
}

// AddExpiryYear adds i to the "expiry_year" field.
func (m *PaymentMethodMutation) AddExpiryYear(i int16) {
	if m.addexpiry_year != nil {
		*m.addexpiry_year += i
	} else {
		m.addexpiry_year = &i
	}
}

// AddedExpiryYear returns the value that was added to the "expiry_year" field in this mutation.
func (m *PaymentMethodMutation) AddedExpiryYear() (r int16, exists bool) {
	v := m.addexpiry_year
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpiryYear clears the value of the "expiry_year" field.
func (m *PaymentMethodMutation) ClearExpiryYear() {
	m.expiry_year = nil
	m.addexpiry_year = nil
	m.clearedFields[paymentmethod.FieldExpiryYear] = struct{}{}
}

// ExpiryYearCleared returns if the "expiry_year" field was cleared in this mutation.
func (m *PaymentMethodMutation) ExpiryYearCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldExpiryYear]
	return ok
}

// ResetExpiryYear resets all changes to the "expiry_year" field.
func (m *PaymentMethodMutation) ResetExpiryYear() {
	m.expiry_year = nil
	m.addexpiry_year = nil
	delete(m.clearedFields, paymentmethod.FieldExpiryYear)
}

// SetIsDefault sets the "is_default" field.
func (m *PaymentMethodMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *PaymentMethodMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "is_default" field.
func (m *PaymentMethodMutation) ClearIsDefault() {
	m.is_default = nil
	m.clearedFields[paymentmethod.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "is_default" field was cleared in this mutation.
func (m *PaymentMethodMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *PaymentMethodMutation) ResetIsDefault() {
	m.is_default = nil
	delete(m.clearedFields, paymentmethod.FieldIsDefault)
}

// SetIsActive sets the "is_active" field.
func (m *PaymentMethodMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PaymentMethodMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ClearIsActive clears the value of the "is_active" field.
func (m *PaymentMethodMutation) ClearIsActive() {
	m.is_active = nil
	m.clearedFields[paymentmethod.FieldIsActive] = struct{}{}
}

// IsActiveCleared returns if the "is_active" field was cleared in this mutation.
func (m *PaymentMethodMutation) IsActiveCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldIsActive]
	return ok
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PaymentMethodMutation) ResetIsActive() {
	m.is_active = nil
	delete(m.clearedFields, paymentmethod.FieldIsActive)
}

// SetExternalID sets the "external_id" field.
func (m *PaymentMethodMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *PaymentMethodMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *PaymentMethodMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[paymentmethod.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *PaymentMethodMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *PaymentMethodMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, paymentmethod.FieldExternalID)
}

// SetMetadata sets the "metadata" field.
func (m *PaymentMethodMutation) SetMetadata(jm json.RawMessage) {
	m.metadata = &jm
	m.appendmetadata = nil
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PaymentMethodMutation) Metadata() (r json.RawMessage, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldMetadata(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// AppendMetadata adds jm to the "metadata" field.
func (m *PaymentMethodMutation) AppendMetadata(jm json.RawMessage) {
	m.appendmetadata = append(m.appendmetadata, jm...)
}

// AppendedMetadata returns the list of values that were appended to the "metadata" field in this mutation.
func (m *PaymentMethodMutation) AppendedMetadata() (json.RawMessage, bool) {
	if len(m.appendmetadata) == 0 {
		return nil, false
	}
	return m.appendmetadata, true
}

// ClearMetadata clears the value of the "metadata" field.
func (m *PaymentMethodMutation) ClearMetadata() {
	m.metadata = nil
	m.appendmetadata = nil
	m.clearedFields[paymentmethod.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *PaymentMethodMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PaymentMethodMutation) ResetMetadata() {
	m.metadata = nil
	m.appendmetadata = nil
	delete(m.clearedFields, paymentmethod.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentMethodMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentMethodMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PaymentMethodMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[paymentmethod.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PaymentMethodMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentMethodMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, paymentmethod.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentMethodMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentMethodMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PaymentMethodMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[paymentmethod.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PaymentMethodMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentMethodMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, paymentmethod.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PaymentMethodMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PaymentMethodMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PaymentMethod entity.
// If the PaymentMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMethodMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PaymentMethodMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[paymentmethod.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PaymentMethodMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[paymentmethod.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PaymentMethodMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, paymentmethod.FieldDeletedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PaymentMethodMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[paymentmethod.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PaymentMethodMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PaymentMethodMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PaymentMethodMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *PaymentMethodMutation) AddTransactionIDs(ids ...string) {
	if m.transactions == nil {
		m.transactions = make(map[string]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *PaymentMethodMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *PaymentMethodMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *PaymentMethodMutation) RemoveTransactionIDs(ids ...string) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *PaymentMethodMutation) RemovedTransactionsIDs() (ids []string) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *PaymentMethodMutation) TransactionsIDs() (ids []string) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *PaymentMethodMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the PaymentMethodMutation builder.
func (m *PaymentMethodMutation) Where(ps ...predicate.PaymentMethod) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMethodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMethodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentMethod, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMethodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMethodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentMethod).
func (m *PaymentMethodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMethodMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.user != nil {
		fields = append(fields, paymentmethod.FieldUserID)
	}
	if m.method_type != nil {
		fields = append(fields, paymentmethod.FieldMethodType)
	}
	if m.provider != nil {
		fields = append(fields, paymentmethod.FieldProvider)
	}
	if m.masked_number != nil {
		fields = append(fields, paymentmethod.FieldMaskedNumber)
	}
	if m.holder_name != nil {
		fields = append(fields, paymentmethod.FieldHolderName)
	}
	if m.expiry_month != nil {
		fields = append(fields, paymentmethod.FieldExpiryMonth)
	}
	if m.expiry_year != nil {
		fields = append(fields, paymentmethod.FieldExpiryYear)
	}
	if m.is_default != nil {
		fields = append(fields, paymentmethod.FieldIsDefault)
	}
	if m.is_active != nil {
		fields = append(fields, paymentmethod.FieldIsActive)
	}
	if m.external_id != nil {
		fields = append(fields, paymentmethod.FieldExternalID)
	}
	if m.metadata != nil {
		fields = append(fields, paymentmethod.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, paymentmethod.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentmethod.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, paymentmethod.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMethodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentmethod.FieldUserID:
		return m.UserID()
	case paymentmethod.FieldMethodType:
		return m.MethodType()
	case paymentmethod.FieldProvider:
		return m.Provider()
	case paymentmethod.FieldMaskedNumber:
		return m.MaskedNumber()
	case paymentmethod.FieldHolderName:
		return m.HolderName()
	case paymentmethod.FieldExpiryMonth:
		return m.ExpiryMonth()
	case paymentmethod.FieldExpiryYear:
		return m.ExpiryYear()
	case paymentmethod.FieldIsDefault:
		return m.IsDefault()
	case paymentmethod.FieldIsActive:
		return m.IsActive()
	case paymentmethod.FieldExternalID:
		return m.ExternalID()
	case paymentmethod.FieldMetadata:
		return m.Metadata()
	case paymentmethod.FieldCreatedAt:
		return m.CreatedAt()
	case paymentmethod.FieldUpdatedAt:
		return m.UpdatedAt()
	case paymentmethod.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMethodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentmethod.FieldUserID:
		return m.OldUserID(ctx)
	case paymentmethod.FieldMethodType:
		return m.OldMethodType(ctx)
	case paymentmethod.FieldProvider:
		return m.OldProvider(ctx)
	case paymentmethod.FieldMaskedNumber:
		return m.OldMaskedNumber(ctx)
	case paymentmethod.FieldHolderName:
		return m.OldHolderName(ctx)
	case paymentmethod.FieldExpiryMonth:
		return m.OldExpiryMonth(ctx)
	case paymentmethod.FieldExpiryYear:
		return m.OldExpiryYear(ctx)
	case paymentmethod.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case paymentmethod.FieldIsActive:
		return m.OldIsActive(ctx)
	case paymentmethod.FieldExternalID:
		return m.OldExternalID(ctx)
	case paymentmethod.FieldMetadata:
		return m.OldMetadata(ctx)
	case paymentmethod.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentmethod.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case paymentmethod.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentMethod field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMethodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentmethod.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case paymentmethod.FieldMethodType:
		v, ok := value.(paymentmethod.MethodType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodType(v)
		return nil
	case paymentmethod.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case paymentmethod.FieldMaskedNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaskedNumber(v)
		return nil
	case paymentmethod.FieldHolderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHolderName(v)
		return nil
	case paymentmethod.FieldExpiryMonth:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryMonth(v)
		return nil
	case paymentmethod.FieldExpiryYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryYear(v)
		return nil
	case paymentmethod.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case paymentmethod.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case paymentmethod.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case paymentmethod.FieldMetadata:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case paymentmethod.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentmethod.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case paymentmethod.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentMethod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMethodMutation) AddedFields() []string {
	var fields []string
	if m.addexpiry_month != nil {
		fields = append(fields, paymentmethod.FieldExpiryMonth)
	}
	if m.addexpiry_year != nil {
		fields = append(fields, paymentmethod.FieldExpiryYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMethodMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentmethod.FieldExpiryMonth:
		return m.AddedExpiryMonth()
	case paymentmethod.FieldExpiryYear:
		return m.AddedExpiryYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMethodMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentmethod.FieldExpiryMonth:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiryMonth(v)
		return nil
	case paymentmethod.FieldExpiryYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiryYear(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentMethod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMethodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentmethod.FieldUserID) {
		fields = append(fields, paymentmethod.FieldUserID)
	}
	if m.FieldCleared(paymentmethod.FieldMaskedNumber) {
		fields = append(fields, paymentmethod.FieldMaskedNumber)
	}
	if m.FieldCleared(paymentmethod.FieldHolderName) {
		fields = append(fields, paymentmethod.FieldHolderName)
	}
	if m.FieldCleared(paymentmethod.FieldExpiryMonth) {
		fields = append(fields, paymentmethod.FieldExpiryMonth)
	}
	if m.FieldCleared(paymentmethod.FieldExpiryYear) {
		fields = append(fields, paymentmethod.FieldExpiryYear)
	}
	if m.FieldCleared(paymentmethod.FieldIsDefault) {
		fields = append(fields, paymentmethod.FieldIsDefault)
	}
	if m.FieldCleared(paymentmethod.FieldIsActive) {
		fields = append(fields, paymentmethod.FieldIsActive)
	}
	if m.FieldCleared(paymentmethod.FieldExternalID) {
		fields = append(fields, paymentmethod.FieldExternalID)
	}
	if m.FieldCleared(paymentmethod.FieldMetadata) {
		fields = append(fields, paymentmethod.FieldMetadata)
	}
	if m.FieldCleared(paymentmethod.FieldCreatedAt) {
		fields = append(fields, paymentmethod.FieldCreatedAt)
	}
	if m.FieldCleared(paymentmethod.FieldUpdatedAt) {
		fields = append(fields, paymentmethod.FieldUpdatedAt)
	}
	if m.FieldCleared(paymentmethod.FieldDeletedAt) {
		fields = append(fields, paymentmethod.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMethodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMethodMutation) ClearField(name string) error {
	switch name {
	case paymentmethod.FieldUserID:
		m.ClearUserID()
		return nil
	case paymentmethod.FieldMaskedNumber:
		m.ClearMaskedNumber()
		return nil
	case paymentmethod.FieldHolderName:
		m.ClearHolderName()
		return nil
	case paymentmethod.FieldExpiryMonth:
		m.ClearExpiryMonth()
		return nil
	case paymentmethod.FieldExpiryYear:
		m.ClearExpiryYear()
		return nil
	case paymentmethod.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	case paymentmethod.FieldIsActive:
		m.ClearIsActive()
		return nil
	case paymentmethod.FieldExternalID:
		m.ClearExternalID()
		return nil
	case paymentmethod.FieldMetadata:
		m.ClearMetadata()
		return nil
	case paymentmethod.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case paymentmethod.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case paymentmethod.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentMethod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMethodMutation) ResetField(name string) error {
	switch name {
	case paymentmethod.FieldUserID:
		m.ResetUserID()
		return nil
	case paymentmethod.FieldMethodType:
		m.ResetMethodType()
		return nil
	case paymentmethod.FieldProvider:
		m.ResetProvider()
		return nil
	case paymentmethod.FieldMaskedNumber:
		m.ResetMaskedNumber()
		return nil
	case paymentmethod.FieldHolderName:
		m.ResetHolderName()
		return nil
	case paymentmethod.FieldExpiryMonth:
		m.ResetExpiryMonth()
		return nil
	case paymentmethod.FieldExpiryYear:
		m.ResetExpiryYear()
		return nil
	case paymentmethod.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case paymentmethod.FieldIsActive:
		m.ResetIsActive()
		return nil
	case paymentmethod.FieldExternalID:
		m.ResetExternalID()
		return nil
	case paymentmethod.FieldMetadata:
		m.ResetMetadata()
		return nil
	case paymentmethod.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentmethod.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case paymentmethod.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentMethod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMethodMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, paymentmethod.EdgeUser)
	}
	if m.transactions != nil {
		edges = append(edges, paymentmethod.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMethodMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentmethod.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case paymentmethod.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMethodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransactions != nil {
		edges = append(edges, paymentmethod.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMethodMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paymentmethod.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMethodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, paymentmethod.EdgeUser)
	}
	if m.clearedtransactions {
		edges = append(edges, paymentmethod.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMethodMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentmethod.EdgeUser:
		return m.cleareduser
	case paymentmethod.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMethodMutation) ClearEdge(name string) error {
	switch name {
	case paymentmethod.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PaymentMethod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMethodMutation) ResetEdge(name string) error {
	switch name {
	case paymentmethod.EdgeUser:
		m.ResetUser()
		return nil
	case paymentmethod.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown PaymentMethod edge %s", name)
}

// PrivacySettingMutation represents an operation that mutates the PrivacySetting nodes in the graph.
type PrivacySettingMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	profile_visibility   *privacysetting.ProfileVisibility
	show_email           *bool
	show_phone           *bool
	show_birth_date      *bool
	allow_search_engines *bool
	data_sharing_consent *bool
	analytics_consent    *bool
	marketing_consent    *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	user                 *string
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*PrivacySetting, error)
	predicates           []predicate.PrivacySetting
}

var _ ent.Mutation = (*PrivacySettingMutation)(nil)

// privacysettingOption allows management of the mutation configuration using functional options.
type privacysettingOption func(*PrivacySettingMutation)

// newPrivacySettingMutation creates new mutation for the PrivacySetting entity.
func newPrivacySettingMutation(c config, op Op, opts ...privacysettingOption) *PrivacySettingMutation {
	m := &PrivacySettingMutation{
		config:        c,
		op:            op,
		typ:           TypePrivacySetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrivacySettingID sets the ID field of the mutation.
func withPrivacySettingID(id string) privacysettingOption {
	return func(m *PrivacySettingMutation) {
		var (
			err   error
			once  sync.Once
			value *PrivacySetting
		)
		m.oldValue = func(ctx context.Context) (*PrivacySetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PrivacySetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrivacySetting sets the old PrivacySetting of the mutation.
func withPrivacySetting(node *PrivacySetting) privacysettingOption {
	return func(m *PrivacySettingMutation) {
		m.oldValue = func(context.Context) (*PrivacySetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrivacySettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrivacySettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PrivacySetting entities.
func (m *PrivacySettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrivacySettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrivacySettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PrivacySetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PrivacySettingMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PrivacySettingMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *PrivacySettingMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[privacysetting.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *PrivacySettingMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PrivacySettingMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, privacysetting.FieldUserID)
}

// SetProfileVisibility sets the "profile_visibility" field.
func (m *PrivacySettingMutation) SetProfileVisibility(pv privacysetting.ProfileVisibility) {
	m.profile_visibility = &pv
}

// ProfileVisibility returns the value of the "profile_visibility" field in the mutation.
func (m *PrivacySettingMutation) ProfileVisibility() (r privacysetting.ProfileVisibility, exists bool) {
	v := m.profile_visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileVisibility returns the old "profile_visibility" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldProfileVisibility(ctx context.Context) (v privacysetting.ProfileVisibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileVisibility: %w", err)
	}
	return oldValue.ProfileVisibility, nil
}

// ClearProfileVisibility clears the value of the "profile_visibility" field.
func (m *PrivacySettingMutation) ClearProfileVisibility() {
	m.profile_visibility = nil
	m.clearedFields[privacysetting.FieldProfileVisibility] = struct{}{}
}

// ProfileVisibilityCleared returns if the "profile_visibility" field was cleared in this mutation.
func (m *PrivacySettingMutation) ProfileVisibilityCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldProfileVisibility]
	return ok
}

// ResetProfileVisibility resets all changes to the "profile_visibility" field.
func (m *PrivacySettingMutation) ResetProfileVisibility() {
	m.profile_visibility = nil
	delete(m.clearedFields, privacysetting.FieldProfileVisibility)
}

// SetShowEmail sets the "show_email" field.
func (m *PrivacySettingMutation) SetShowEmail(b bool) {
	m.show_email = &b
}

// ShowEmail returns the value of the "show_email" field in the mutation.
func (m *PrivacySettingMutation) ShowEmail() (r bool, exists bool) {
	v := m.show_email
	if v == nil {
		return
	}
	return *v, true
}

// OldShowEmail returns the old "show_email" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldShowEmail(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowEmail: %w", err)
	}
	return oldValue.ShowEmail, nil
}

// ClearShowEmail clears the value of the "show_email" field.
func (m *PrivacySettingMutation) ClearShowEmail() {
	m.show_email = nil
	m.clearedFields[privacysetting.FieldShowEmail] = struct{}{}
}

// ShowEmailCleared returns if the "show_email" field was cleared in this mutation.
func (m *PrivacySettingMutation) ShowEmailCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldShowEmail]
	return ok
}

// ResetShowEmail resets all changes to the "show_email" field.
func (m *PrivacySettingMutation) ResetShowEmail() {
	m.show_email = nil
	delete(m.clearedFields, privacysetting.FieldShowEmail)
}

// SetShowPhone sets the "show_phone" field.
func (m *PrivacySettingMutation) SetShowPhone(b bool) {
	m.show_phone = &b
}

// ShowPhone returns the value of the "show_phone" field in the mutation.
func (m *PrivacySettingMutation) ShowPhone() (r bool, exists bool) {
	v := m.show_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldShowPhone returns the old "show_phone" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldShowPhone(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowPhone: %w", err)
	}
	return oldValue.ShowPhone, nil
}

// ClearShowPhone clears the value of the "show_phone" field.
func (m *PrivacySettingMutation) ClearShowPhone() {
	m.show_phone = nil
	m.clearedFields[privacysetting.FieldShowPhone] = struct{}{}
}

// ShowPhoneCleared returns if the "show_phone" field was cleared in this mutation.
func (m *PrivacySettingMutation) ShowPhoneCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldShowPhone]
	return ok
}

// ResetShowPhone resets all changes to the "show_phone" field.
func (m *PrivacySettingMutation) ResetShowPhone() {
	m.show_phone = nil
	delete(m.clearedFields, privacysetting.FieldShowPhone)
}

// SetShowBirthDate sets the "show_birth_date" field.
func (m *PrivacySettingMutation) SetShowBirthDate(b bool) {
	m.show_birth_date = &b
}

// ShowBirthDate returns the value of the "show_birth_date" field in the mutation.
func (m *PrivacySettingMutation) ShowBirthDate() (r bool, exists bool) {
	v := m.show_birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShowBirthDate returns the old "show_birth_date" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldShowBirthDate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowBirthDate: %w", err)
	}
	return oldValue.ShowBirthDate, nil
}

// ClearShowBirthDate clears the value of the "show_birth_date" field.
func (m *PrivacySettingMutation) ClearShowBirthDate() {
	m.show_birth_date = nil
	m.clearedFields[privacysetting.FieldShowBirthDate] = struct{}{}
}

// ShowBirthDateCleared returns if the "show_birth_date" field was cleared in this mutation.
func (m *PrivacySettingMutation) ShowBirthDateCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldShowBirthDate]
	return ok
}

// ResetShowBirthDate resets all changes to the "show_birth_date" field.
func (m *PrivacySettingMutation) ResetShowBirthDate() {
	m.show_birth_date = nil
	delete(m.clearedFields, privacysetting.FieldShowBirthDate)
}

// SetAllowSearchEngines sets the "allow_search_engines" field.
func (m *PrivacySettingMutation) SetAllowSearchEngines(b bool) {
	m.allow_search_engines = &b
}

// AllowSearchEngines returns the value of the "allow_search_engines" field in the mutation.
func (m *PrivacySettingMutation) AllowSearchEngines() (r bool, exists bool) {
	v := m.allow_search_engines
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowSearchEngines returns the old "allow_search_engines" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldAllowSearchEngines(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowSearchEngines is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowSearchEngines requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowSearchEngines: %w", err)
	}
	return oldValue.AllowSearchEngines, nil
}

// ClearAllowSearchEngines clears the value of the "allow_search_engines" field.
func (m *PrivacySettingMutation) ClearAllowSearchEngines() {
	m.allow_search_engines = nil
	m.clearedFields[privacysetting.FieldAllowSearchEngines] = struct{}{}
}

// AllowSearchEnginesCleared returns if the "allow_search_engines" field was cleared in this mutation.
func (m *PrivacySettingMutation) AllowSearchEnginesCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldAllowSearchEngines]
	return ok
}

// ResetAllowSearchEngines resets all changes to the "allow_search_engines" field.
func (m *PrivacySettingMutation) ResetAllowSearchEngines() {
	m.allow_search_engines = nil
	delete(m.clearedFields, privacysetting.FieldAllowSearchEngines)
}

// SetDataSharingConsent sets the "data_sharing_consent" field.
func (m *PrivacySettingMutation) SetDataSharingConsent(b bool) {
	m.data_sharing_consent = &b
}

// DataSharingConsent returns the value of the "data_sharing_consent" field in the mutation.
func (m *PrivacySettingMutation) DataSharingConsent() (r bool, exists bool) {
	v := m.data_sharing_consent
	if v == nil {
		return
	}
	return *v, true
}

// OldDataSharingConsent returns the old "data_sharing_consent" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldDataSharingConsent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataSharingConsent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataSharingConsent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataSharingConsent: %w", err)
	}
	return oldValue.DataSharingConsent, nil
}

// ClearDataSharingConsent clears the value of the "data_sharing_consent" field.
func (m *PrivacySettingMutation) ClearDataSharingConsent() {
	m.data_sharing_consent = nil
	m.clearedFields[privacysetting.FieldDataSharingConsent] = struct{}{}
}

// DataSharingConsentCleared returns if the "data_sharing_consent" field was cleared in this mutation.
func (m *PrivacySettingMutation) DataSharingConsentCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldDataSharingConsent]
	return ok
}

// ResetDataSharingConsent resets all changes to the "data_sharing_consent" field.
func (m *PrivacySettingMutation) ResetDataSharingConsent() {
	m.data_sharing_consent = nil
	delete(m.clearedFields, privacysetting.FieldDataSharingConsent)
}

// SetAnalyticsConsent sets the "analytics_consent" field.
func (m *PrivacySettingMutation) SetAnalyticsConsent(b bool) {
	m.analytics_consent = &b
}

// AnalyticsConsent returns the value of the "analytics_consent" field in the mutation.
func (m *PrivacySettingMutation) AnalyticsConsent() (r bool, exists bool) {
	v := m.analytics_consent
	if v == nil {
		return
	}
	return *v, true
}

// OldAnalyticsConsent returns the old "analytics_consent" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldAnalyticsConsent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnalyticsConsent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnalyticsConsent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnalyticsConsent: %w", err)
	}
	return oldValue.AnalyticsConsent, nil
}

// ClearAnalyticsConsent clears the value of the "analytics_consent" field.
func (m *PrivacySettingMutation) ClearAnalyticsConsent() {
	m.analytics_consent = nil
	m.clearedFields[privacysetting.FieldAnalyticsConsent] = struct{}{}
}

// AnalyticsConsentCleared returns if the "analytics_consent" field was cleared in this mutation.
func (m *PrivacySettingMutation) AnalyticsConsentCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldAnalyticsConsent]
	return ok
}

// ResetAnalyticsConsent resets all changes to the "analytics_consent" field.
func (m *PrivacySettingMutation) ResetAnalyticsConsent() {
	m.analytics_consent = nil
	delete(m.clearedFields, privacysetting.FieldAnalyticsConsent)
}

// SetMarketingConsent sets the "marketing_consent" field.
func (m *PrivacySettingMutation) SetMarketingConsent(b bool) {
	m.marketing_consent = &b
}

// MarketingConsent returns the value of the "marketing_consent" field in the mutation.
func (m *PrivacySettingMutation) MarketingConsent() (r bool, exists bool) {
	v := m.marketing_consent
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketingConsent returns the old "marketing_consent" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldMarketingConsent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketingConsent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketingConsent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketingConsent: %w", err)
	}
	return oldValue.MarketingConsent, nil
}

// ClearMarketingConsent clears the value of the "marketing_consent" field.
func (m *PrivacySettingMutation) ClearMarketingConsent() {
	m.marketing_consent = nil
	m.clearedFields[privacysetting.FieldMarketingConsent] = struct{}{}
}

// MarketingConsentCleared returns if the "marketing_consent" field was cleared in this mutation.
func (m *PrivacySettingMutation) MarketingConsentCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldMarketingConsent]
	return ok
}

// ResetMarketingConsent resets all changes to the "marketing_consent" field.
func (m *PrivacySettingMutation) ResetMarketingConsent() {
	m.marketing_consent = nil
	delete(m.clearedFields, privacysetting.FieldMarketingConsent)
}

// SetCreatedAt sets the "created_at" field.
func (m *PrivacySettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PrivacySettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PrivacySettingMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[privacysetting.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PrivacySettingMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PrivacySettingMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, privacysetting.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PrivacySettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PrivacySettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PrivacySetting entity.
// If the PrivacySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivacySettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PrivacySettingMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[privacysetting.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PrivacySettingMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[privacysetting.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PrivacySettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, privacysetting.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PrivacySettingMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[privacysetting.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PrivacySettingMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PrivacySettingMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PrivacySettingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PrivacySettingMutation builder.
func (m *PrivacySettingMutation) Where(ps ...predicate.PrivacySetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrivacySettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrivacySettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PrivacySetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrivacySettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrivacySettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PrivacySetting).
func (m *PrivacySettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrivacySettingMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, privacysetting.FieldUserID)
	}
	if m.profile_visibility != nil {
		fields = append(fields, privacysetting.FieldProfileVisibility)
	}
	if m.show_email != nil {
		fields = append(fields, privacysetting.FieldShowEmail)
	}
	if m.show_phone != nil {
		fields = append(fields, privacysetting.FieldShowPhone)
	}
	if m.show_birth_date != nil {
		fields = append(fields, privacysetting.FieldShowBirthDate)
	}
	if m.allow_search_engines != nil {
		fields = append(fields, privacysetting.FieldAllowSearchEngines)
	}
	if m.data_sharing_consent != nil {
		fields = append(fields, privacysetting.FieldDataSharingConsent)
	}
	if m.analytics_consent != nil {
		fields = append(fields, privacysetting.FieldAnalyticsConsent)
	}
	if m.marketing_consent != nil {
		fields = append(fields, privacysetting.FieldMarketingConsent)
	}
	if m.created_at != nil {
		fields = append(fields, privacysetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, privacysetting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrivacySettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case privacysetting.FieldUserID:
		return m.UserID()
	case privacysetting.FieldProfileVisibility:
		return m.ProfileVisibility()
	case privacysetting.FieldShowEmail:
		return m.ShowEmail()
	case privacysetting.FieldShowPhone:
		return m.ShowPhone()
	case privacysetting.FieldShowBirthDate:
		return m.ShowBirthDate()
	case privacysetting.FieldAllowSearchEngines:
		return m.AllowSearchEngines()
	case privacysetting.FieldDataSharingConsent:
		return m.DataSharingConsent()
	case privacysetting.FieldAnalyticsConsent:
		return m.AnalyticsConsent()
	case privacysetting.FieldMarketingConsent:
		return m.MarketingConsent()
	case privacysetting.FieldCreatedAt:
		return m.CreatedAt()
	case privacysetting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrivacySettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case privacysetting.FieldUserID:
		return m.OldUserID(ctx)
	case privacysetting.FieldProfileVisibility:
		return m.OldProfileVisibility(ctx)
	case privacysetting.FieldShowEmail:
		return m.OldShowEmail(ctx)
	case privacysetting.FieldShowPhone:
		return m.OldShowPhone(ctx)
	case privacysetting.FieldShowBirthDate:
		return m.OldShowBirthDate(ctx)
	case privacysetting.FieldAllowSearchEngines:
		return m.OldAllowSearchEngines(ctx)
	case privacysetting.FieldDataSharingConsent:
		return m.OldDataSharingConsent(ctx)
	case privacysetting.FieldAnalyticsConsent:
		return m.OldAnalyticsConsent(ctx)
	case privacysetting.FieldMarketingConsent:
		return m.OldMarketingConsent(ctx)
	case privacysetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case privacysetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PrivacySetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrivacySettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case privacysetting.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case privacysetting.FieldProfileVisibility:
		v, ok := value.(privacysetting.ProfileVisibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileVisibility(v)
		return nil
	case privacysetting.FieldShowEmail:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowEmail(v)
		return nil
	case privacysetting.FieldShowPhone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowPhone(v)
		return nil
	case privacysetting.FieldShowBirthDate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowBirthDate(v)
		return nil
	case privacysetting.FieldAllowSearchEngines:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowSearchEngines(v)
		return nil
	case privacysetting.FieldDataSharingConsent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataSharingConsent(v)
		return nil
	case privacysetting.FieldAnalyticsConsent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnalyticsConsent(v)
		return nil
	case privacysetting.FieldMarketingConsent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketingConsent(v)
		return nil
	case privacysetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case privacysetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PrivacySetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrivacySettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrivacySettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrivacySettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PrivacySetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrivacySettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(privacysetting.FieldUserID) {
		fields = append(fields, privacysetting.FieldUserID)
	}
	if m.FieldCleared(privacysetting.FieldProfileVisibility) {
		fields = append(fields, privacysetting.FieldProfileVisibility)
	}
	if m.FieldCleared(privacysetting.FieldShowEmail) {
		fields = append(fields, privacysetting.FieldShowEmail)
	}
	if m.FieldCleared(privacysetting.FieldShowPhone) {
		fields = append(fields, privacysetting.FieldShowPhone)
	}
	if m.FieldCleared(privacysetting.FieldShowBirthDate) {
		fields = append(fields, privacysetting.FieldShowBirthDate)
	}
	if m.FieldCleared(privacysetting.FieldAllowSearchEngines) {
		fields = append(fields, privacysetting.FieldAllowSearchEngines)
	}
	if m.FieldCleared(privacysetting.FieldDataSharingConsent) {
		fields = append(fields, privacysetting.FieldDataSharingConsent)
	}
	if m.FieldCleared(privacysetting.FieldAnalyticsConsent) {
		fields = append(fields, privacysetting.FieldAnalyticsConsent)
	}
	if m.FieldCleared(privacysetting.FieldMarketingConsent) {
		fields = append(fields, privacysetting.FieldMarketingConsent)
	}
	if m.FieldCleared(privacysetting.FieldCreatedAt) {
		fields = append(fields, privacysetting.FieldCreatedAt)
	}
	if m.FieldCleared(privacysetting.FieldUpdatedAt) {
		fields = append(fields, privacysetting.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrivacySettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrivacySettingMutation) ClearField(name string) error {
	switch name {
	case privacysetting.FieldUserID:
		m.ClearUserID()
		return nil
	case privacysetting.FieldProfileVisibility:
		m.ClearProfileVisibility()
		return nil
	case privacysetting.FieldShowEmail:
		m.ClearShowEmail()
		return nil
	case privacysetting.FieldShowPhone:
		m.ClearShowPhone()
		return nil
	case privacysetting.FieldShowBirthDate:
		m.ClearShowBirthDate()
		return nil
	case privacysetting.FieldAllowSearchEngines:
		m.ClearAllowSearchEngines()
		return nil
	case privacysetting.FieldDataSharingConsent:
		m.ClearDataSharingConsent()
		return nil
	case privacysetting.FieldAnalyticsConsent:
		m.ClearAnalyticsConsent()
		return nil
	case privacysetting.FieldMarketingConsent:
		m.ClearMarketingConsent()
		return nil
	case privacysetting.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case privacysetting.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PrivacySetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrivacySettingMutation) ResetField(name string) error {
	switch name {
	case privacysetting.FieldUserID:
		m.ResetUserID()
		return nil
	case privacysetting.FieldProfileVisibility:
		m.ResetProfileVisibility()
		return nil
	case privacysetting.FieldShowEmail:
		m.ResetShowEmail()
		return nil
	case privacysetting.FieldShowPhone:
		m.ResetShowPhone()
		return nil
	case privacysetting.FieldShowBirthDate:
		m.ResetShowBirthDate()
		return nil
	case privacysetting.FieldAllowSearchEngines:
		m.ResetAllowSearchEngines()
		return nil
	case privacysetting.FieldDataSharingConsent:
		m.ResetDataSharingConsent()
		return nil
	case privacysetting.FieldAnalyticsConsent:
		m.ResetAnalyticsConsent()
		return nil
	case privacysetting.FieldMarketingConsent:
		m.ResetMarketingConsent()
		return nil
	case privacysetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case privacysetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PrivacySetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrivacySettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, privacysetting.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrivacySettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case privacysetting.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrivacySettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrivacySettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrivacySettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, privacysetting.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrivacySettingMutation) EdgeCleared(name string) bool {
	switch name {
	case privacysetting.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrivacySettingMutation) ClearEdge(name string) error {
	switch name {
	case privacysetting.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PrivacySetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrivacySettingMutation) ResetEdge(name string) error {
	switch name {
	case privacysetting.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PrivacySetting edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	transaction_type        *transaction.TransactionType
	amount                  *float64
	addamount               *float64
	currency                *string
	status                  *transaction.Status
	description             *string
	external_transaction_id *string
	reference_number        *string
	metadata                *json.RawMessage
	appendmetadata          json.RawMessage
	processed_at            *time.Time
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	user                    *string
	cleareduser             bool
	payment_method          *string
	clearedpayment_method   bool
	done                    bool
	oldValue                func(context.Context) (*Transaction, error)
	predicates              []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id string) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *TransactionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TransactionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *TransactionMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[transaction.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TransactionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TransactionMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, transaction.FieldUserID)
}

// SetPaymentMethodID sets the "payment_method_id" field.
func (m *TransactionMutation) SetPaymentMethodID(s string) {
	m.payment_method = &s
}

// PaymentMethodID returns the value of the "payment_method_id" field in the mutation.
func (m *TransactionMutation) PaymentMethodID() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethodID returns the old "payment_method_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPaymentMethodID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethodID: %w", err)
	}
	return oldValue.PaymentMethodID, nil
}

// ClearPaymentMethodID clears the value of the "payment_method_id" field.
func (m *TransactionMutation) ClearPaymentMethodID() {
	m.payment_method = nil
	m.clearedFields[transaction.FieldPaymentMethodID] = struct{}{}
}

// PaymentMethodIDCleared returns if the "payment_method_id" field was cleared in this mutation.
func (m *TransactionMutation) PaymentMethodIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldPaymentMethodID]
	return ok
}

// ResetPaymentMethodID resets all changes to the "payment_method_id" field.
func (m *TransactionMutation) ResetPaymentMethodID() {
	m.payment_method = nil
	delete(m.clearedFields, transaction.FieldPaymentMethodID)
}

// SetTransactionType sets the "transaction_type" field.
func (m *TransactionMutation) SetTransactionType(tt transaction.TransactionType) {
	m.transaction_type = &tt
}

// TransactionType returns the value of the "transaction_type" field in the mutation.
func (m *TransactionMutation) TransactionType() (r transaction.TransactionType, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "transaction_type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionType(ctx context.Context) (v transaction.TransactionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ResetTransactionType resets all changes to the "transaction_type" field.
func (m *TransactionMutation) ResetTransactionType() {
	m.transaction_type = nil
}

// SetAmount sets the "amount" field.
func (m *TransactionMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TransactionMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCurrency sets the "currency" field.
func (m *TransactionMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *TransactionMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *TransactionMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[transaction.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *TransactionMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[transaction.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *TransactionMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, transaction.FieldCurrency)
}

// SetStatus sets the "status" field.
func (m *TransactionMutation) SetStatus(t transaction.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TransactionMutation) Status() (r transaction.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldStatus(ctx context.Context) (v transaction.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TransactionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[transaction.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TransactionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[transaction.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TransactionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, transaction.FieldStatus)
}

// SetDescription sets the "description" field.
func (m *TransactionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransactionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TransactionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[transaction.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TransactionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[transaction.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TransactionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, transaction.FieldDescription)
}

// SetExternalTransactionID sets the "external_transaction_id" field.
func (m *TransactionMutation) SetExternalTransactionID(s string) {
	m.external_transaction_id = &s
}

// ExternalTransactionID returns the value of the "external_transaction_id" field in the mutation.
func (m *TransactionMutation) ExternalTransactionID() (r string, exists bool) {
	v := m.external_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalTransactionID returns the old "external_transaction_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldExternalTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalTransactionID: %w", err)
	}
	return oldValue.ExternalTransactionID, nil
}

// ClearExternalTransactionID clears the value of the "external_transaction_id" field.
func (m *TransactionMutation) ClearExternalTransactionID() {
	m.external_transaction_id = nil
	m.clearedFields[transaction.FieldExternalTransactionID] = struct{}{}
}

// ExternalTransactionIDCleared returns if the "external_transaction_id" field was cleared in this mutation.
func (m *TransactionMutation) ExternalTransactionIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldExternalTransactionID]
	return ok
}

// ResetExternalTransactionID resets all changes to the "external_transaction_id" field.
func (m *TransactionMutation) ResetExternalTransactionID() {
	m.external_transaction_id = nil
	delete(m.clearedFields, transaction.FieldExternalTransactionID)
}

// SetReferenceNumber sets the "reference_number" field.
func (m *TransactionMutation) SetReferenceNumber(s string) {
	m.reference_number = &s
}

// ReferenceNumber returns the value of the "reference_number" field in the mutation.
func (m *TransactionMutation) ReferenceNumber() (r string, exists bool) {
	v := m.reference_number
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceNumber returns the old "reference_number" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldReferenceNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceNumber: %w", err)
	}
	return oldValue.ReferenceNumber, nil
}

// ClearReferenceNumber clears the value of the "reference_number" field.
func (m *TransactionMutation) ClearReferenceNumber() {
	m.reference_number = nil
	m.clearedFields[transaction.FieldReferenceNumber] = struct{}{}
}

// ReferenceNumberCleared returns if the "reference_number" field was cleared in this mutation.
func (m *TransactionMutation) ReferenceNumberCleared() bool {
	_, ok := m.clearedFields[transaction.FieldReferenceNumber]
	return ok
}

// ResetReferenceNumber resets all changes to the "reference_number" field.
func (m *TransactionMutation) ResetReferenceNumber() {
	m.reference_number = nil
	delete(m.clearedFields, transaction.FieldReferenceNumber)
}

// SetMetadata sets the "metadata" field.
func (m *TransactionMutation) SetMetadata(jm json.RawMessage) {
	m.metadata = &jm
	m.appendmetadata = nil
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *TransactionMutation) Metadata() (r json.RawMessage, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldMetadata(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// AppendMetadata adds jm to the "metadata" field.
func (m *TransactionMutation) AppendMetadata(jm json.RawMessage) {
	m.appendmetadata = append(m.appendmetadata, jm...)
}

// AppendedMetadata returns the list of values that were appended to the "metadata" field in this mutation.
func (m *TransactionMutation) AppendedMetadata() (json.RawMessage, bool) {
	if len(m.appendmetadata) == 0 {
		return nil, false
	}
	return m.appendmetadata, true
}

// ClearMetadata clears the value of the "metadata" field.
func (m *TransactionMutation) ClearMetadata() {
	m.metadata = nil
	m.appendmetadata = nil
	m.clearedFields[transaction.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *TransactionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[transaction.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *TransactionMutation) ResetMetadata() {
	m.metadata = nil
	m.appendmetadata = nil
	delete(m.clearedFields, transaction.FieldMetadata)
}

// SetProcessedAt sets the "processed_at" field.
func (m *TransactionMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *TransactionMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldProcessedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (m *TransactionMutation) ClearProcessedAt() {
	m.processed_at = nil
	m.clearedFields[transaction.FieldProcessedAt] = struct{}{}
}

// ProcessedAtCleared returns if the "processed_at" field was cleared in this mutation.
func (m *TransactionMutation) ProcessedAtCleared() bool {
	_, ok := m.clearedFields[transaction.FieldProcessedAt]
	return ok
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *TransactionMutation) ResetProcessedAt() {
	m.processed_at = nil
	delete(m.clearedFields, transaction.FieldProcessedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TransactionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[transaction.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TransactionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[transaction.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, transaction.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TransactionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[transaction.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TransactionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[transaction.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, transaction.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *TransactionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[transaction.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TransactionMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TransactionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPaymentMethod clears the "payment_method" edge to the PaymentMethod entity.
func (m *TransactionMutation) ClearPaymentMethod() {
	m.clearedpayment_method = true
	m.clearedFields[transaction.FieldPaymentMethodID] = struct{}{}
}

// PaymentMethodCleared reports if the "payment_method" edge to the PaymentMethod entity was cleared.
func (m *TransactionMutation) PaymentMethodCleared() bool {
	return m.PaymentMethodIDCleared() || m.clearedpayment_method
}

// PaymentMethodIDs returns the "payment_method" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentMethodID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) PaymentMethodIDs() (ids []string) {
	if id := m.payment_method; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentMethod resets all changes to the "payment_method" edge.
func (m *TransactionMutation) ResetPaymentMethod() {
	m.payment_method = nil
	m.clearedpayment_method = false
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, transaction.FieldUserID)
	}
	if m.payment_method != nil {
		fields = append(fields, transaction.FieldPaymentMethodID)
	}
	if m.transaction_type != nil {
		fields = append(fields, transaction.FieldTransactionType)
	}
	if m.amount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, transaction.FieldCurrency)
	}
	if m.status != nil {
		fields = append(fields, transaction.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, transaction.FieldDescription)
	}
	if m.external_transaction_id != nil {
		fields = append(fields, transaction.FieldExternalTransactionID)
	}
	if m.reference_number != nil {
		fields = append(fields, transaction.FieldReferenceNumber)
	}
	if m.metadata != nil {
		fields = append(fields, transaction.FieldMetadata)
	}
	if m.processed_at != nil {
		fields = append(fields, transaction.FieldProcessedAt)
	}
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transaction.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldUserID:
		return m.UserID()
	case transaction.FieldPaymentMethodID:
		return m.PaymentMethodID()
	case transaction.FieldTransactionType:
		return m.TransactionType()
	case transaction.FieldAmount:
		return m.Amount()
	case transaction.FieldCurrency:
		return m.Currency()
	case transaction.FieldStatus:
		return m.Status()
	case transaction.FieldDescription:
		return m.Description()
	case transaction.FieldExternalTransactionID:
		return m.ExternalTransactionID()
	case transaction.FieldReferenceNumber:
		return m.ReferenceNumber()
	case transaction.FieldMetadata:
		return m.Metadata()
	case transaction.FieldProcessedAt:
		return m.ProcessedAt()
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	case transaction.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldUserID:
		return m.OldUserID(ctx)
	case transaction.FieldPaymentMethodID:
		return m.OldPaymentMethodID(ctx)
	case transaction.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case transaction.FieldAmount:
		return m.OldAmount(ctx)
	case transaction.FieldCurrency:
		return m.OldCurrency(ctx)
	case transaction.FieldStatus:
		return m.OldStatus(ctx)
	case transaction.FieldDescription:
		return m.OldDescription(ctx)
	case transaction.FieldExternalTransactionID:
		return m.OldExternalTransactionID(ctx)
	case transaction.FieldReferenceNumber:
		return m.OldReferenceNumber(ctx)
	case transaction.FieldMetadata:
		return m.OldMetadata(ctx)
	case transaction.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case transaction.FieldPaymentMethodID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethodID(v)
		return nil
	case transaction.FieldTransactionType:
		v, ok := value.(transaction.TransactionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transaction.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case transaction.FieldStatus:
		v, ok := value.(transaction.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transaction.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case transaction.FieldExternalTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalTransactionID(v)
		return nil
	case transaction.FieldReferenceNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceNumber(v)
		return nil
	case transaction.FieldMetadata:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case transaction.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldUserID) {
		fields = append(fields, transaction.FieldUserID)
	}
	if m.FieldCleared(transaction.FieldPaymentMethodID) {
		fields = append(fields, transaction.FieldPaymentMethodID)
	}
	if m.FieldCleared(transaction.FieldCurrency) {
		fields = append(fields, transaction.FieldCurrency)
	}
	if m.FieldCleared(transaction.FieldStatus) {
		fields = append(fields, transaction.FieldStatus)
	}
	if m.FieldCleared(transaction.FieldDescription) {
		fields = append(fields, transaction.FieldDescription)
	}
	if m.FieldCleared(transaction.FieldExternalTransactionID) {
		fields = append(fields, transaction.FieldExternalTransactionID)
	}
	if m.FieldCleared(transaction.FieldReferenceNumber) {
		fields = append(fields, transaction.FieldReferenceNumber)
	}
	if m.FieldCleared(transaction.FieldMetadata) {
		fields = append(fields, transaction.FieldMetadata)
	}
	if m.FieldCleared(transaction.FieldProcessedAt) {
		fields = append(fields, transaction.FieldProcessedAt)
	}
	if m.FieldCleared(transaction.FieldCreatedAt) {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.FieldCleared(transaction.FieldUpdatedAt) {
		fields = append(fields, transaction.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldUserID:
		m.ClearUserID()
		return nil
	case transaction.FieldPaymentMethodID:
		m.ClearPaymentMethodID()
		return nil
	case transaction.FieldCurrency:
		m.ClearCurrency()
		return nil
	case transaction.FieldStatus:
		m.ClearStatus()
		return nil
	case transaction.FieldDescription:
		m.ClearDescription()
		return nil
	case transaction.FieldExternalTransactionID:
		m.ClearExternalTransactionID()
		return nil
	case transaction.FieldReferenceNumber:
		m.ClearReferenceNumber()
		return nil
	case transaction.FieldMetadata:
		m.ClearMetadata()
		return nil
	case transaction.FieldProcessedAt:
		m.ClearProcessedAt()
		return nil
	case transaction.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case transaction.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldUserID:
		m.ResetUserID()
		return nil
	case transaction.FieldPaymentMethodID:
		m.ResetPaymentMethodID()
		return nil
	case transaction.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case transaction.FieldAmount:
		m.ResetAmount()
		return nil
	case transaction.FieldCurrency:
		m.ResetCurrency()
		return nil
	case transaction.FieldStatus:
		m.ResetStatus()
		return nil
	case transaction.FieldDescription:
		m.ResetDescription()
		return nil
	case transaction.FieldExternalTransactionID:
		m.ResetExternalTransactionID()
		return nil
	case transaction.FieldReferenceNumber:
		m.ResetReferenceNumber()
		return nil
	case transaction.FieldMetadata:
		m.ResetMetadata()
		return nil
	case transaction.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, transaction.EdgeUser)
	}
	if m.payment_method != nil {
		edges = append(edges, transaction.EdgePaymentMethod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgePaymentMethod:
		if id := m.payment_method; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, transaction.EdgeUser)
	}
	if m.clearedpayment_method {
		edges = append(edges, transaction.EdgePaymentMethod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeUser:
		return m.cleareduser
	case transaction.EdgePaymentMethod:
		return m.clearedpayment_method
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeUser:
		m.ClearUser()
		return nil
	case transaction.EdgePaymentMethod:
		m.ClearPaymentMethod()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeUser:
		m.ResetUser()
		return nil
	case transaction.EdgePaymentMethod:
		m.ResetPaymentMethod()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	email                       *string
	username                    *string
	password_hash               *string
	first_name                  *string
	last_name                   *string
	phone                       *string
	date_of_birth               *time.Time
	avatar_url                  *string
	email_verified              *bool
	phone_verified              *bool
	account_status              *user.AccountStatus
	last_login_at               *time.Time
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	clearedFields               map[string]struct{}
	activity_logs               map[string]struct{}
	removedactivity_logs        map[string]struct{}
	clearedactivity_logs        bool
	api_keys                    map[string]struct{}
	removedapi_keys             map[string]struct{}
	clearedapi_keys             bool
	notification_setting        *string
	clearednotification_setting bool
	payment_methods             map[string]struct{}
	removedpayment_methods      map[string]struct{}
	clearedpayment_methods      bool
	privacy_setting             *string
	clearedprivacy_setting      bool
	transactions                map[string]struct{}
	removedtransactions         map[string]struct{}
	clearedtransactions         bool
	user_profile                *string
	cleareduser_profile         bool
	user_sessions               map[string]struct{}
	removeduser_sessions        map[string]struct{}
	cleareduser_sessions        bool
	user_tokens                 map[string]struct{}
	removeduser_tokens          map[string]struct{}
	cleareduser_tokens          bool
	user_2fa                    *string
	cleareduser_2fa             bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *UserMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *UserMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ClearDateOfBirth clears the value of the "date_of_birth" field.
func (m *UserMutation) ClearDateOfBirth() {
	m.date_of_birth = nil
	m.clearedFields[user.FieldDateOfBirth] = struct{}{}
}

// DateOfBirthCleared returns if the "date_of_birth" field was cleared in this mutation.
func (m *UserMutation) DateOfBirthCleared() bool {
	_, ok := m.clearedFields[user.FieldDateOfBirth]
	return ok
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *UserMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
	delete(m.clearedFields, user.FieldDateOfBirth)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ClearEmailVerified clears the value of the "email_verified" field.
func (m *UserMutation) ClearEmailVerified() {
	m.email_verified = nil
	m.clearedFields[user.FieldEmailVerified] = struct{}{}
}

// EmailVerifiedCleared returns if the "email_verified" field was cleared in this mutation.
func (m *UserMutation) EmailVerifiedCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerified]
	return ok
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
	delete(m.clearedFields, user.FieldEmailVerified)
}

// SetPhoneVerified sets the "phone_verified" field.
func (m *UserMutation) SetPhoneVerified(b bool) {
	m.phone_verified = &b
}

// PhoneVerified returns the value of the "phone_verified" field in the mutation.
func (m *UserMutation) PhoneVerified() (r bool, exists bool) {
	v := m.phone_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneVerified returns the old "phone_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneVerified: %w", err)
	}
	return oldValue.PhoneVerified, nil
}

// ClearPhoneVerified clears the value of the "phone_verified" field.
func (m *UserMutation) ClearPhoneVerified() {
	m.phone_verified = nil
	m.clearedFields[user.FieldPhoneVerified] = struct{}{}
}

// PhoneVerifiedCleared returns if the "phone_verified" field was cleared in this mutation.
func (m *UserMutation) PhoneVerifiedCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneVerified]
	return ok
}

// ResetPhoneVerified resets all changes to the "phone_verified" field.
func (m *UserMutation) ResetPhoneVerified() {
	m.phone_verified = nil
	delete(m.clearedFields, user.FieldPhoneVerified)
}

// SetAccountStatus sets the "account_status" field.
func (m *UserMutation) SetAccountStatus(us user.AccountStatus) {
	m.account_status = &us
}

// AccountStatus returns the value of the "account_status" field in the mutation.
func (m *UserMutation) AccountStatus() (r user.AccountStatus, exists bool) {
	v := m.account_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountStatus returns the old "account_status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccountStatus(ctx context.Context) (v user.AccountStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountStatus: %w", err)
	}
	return oldValue.AccountStatus, nil
}

// ClearAccountStatus clears the value of the "account_status" field.
func (m *UserMutation) ClearAccountStatus() {
	m.account_status = nil
	m.clearedFields[user.FieldAccountStatus] = struct{}{}
}

// AccountStatusCleared returns if the "account_status" field was cleared in this mutation.
func (m *UserMutation) AccountStatusCleared() bool {
	_, ok := m.clearedFields[user.FieldAccountStatus]
	return ok
}

// ResetAccountStatus resets all changes to the "account_status" field.
func (m *UserMutation) ResetAccountStatus() {
	m.account_status = nil
	delete(m.clearedFields, user.FieldAccountStatus)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// AddActivityLogIDs adds the "activity_logs" edge to the ActivityLog entity by ids.
func (m *UserMutation) AddActivityLogIDs(ids ...string) {
	if m.activity_logs == nil {
		m.activity_logs = make(map[string]struct{})
	}
	for i := range ids {
		m.activity_logs[ids[i]] = struct{}{}
	}
}

// ClearActivityLogs clears the "activity_logs" edge to the ActivityLog entity.
func (m *UserMutation) ClearActivityLogs() {
	m.clearedactivity_logs = true
}

// ActivityLogsCleared reports if the "activity_logs" edge to the ActivityLog entity was cleared.
func (m *UserMutation) ActivityLogsCleared() bool {
	return m.clearedactivity_logs
}

// RemoveActivityLogIDs removes the "activity_logs" edge to the ActivityLog entity by IDs.
func (m *UserMutation) RemoveActivityLogIDs(ids ...string) {
	if m.removedactivity_logs == nil {
		m.removedactivity_logs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activity_logs, ids[i])
		m.removedactivity_logs[ids[i]] = struct{}{}
	}
}

// RemovedActivityLogs returns the removed IDs of the "activity_logs" edge to the ActivityLog entity.
func (m *UserMutation) RemovedActivityLogsIDs() (ids []string) {
	for id := range m.removedactivity_logs {
		ids = append(ids, id)
	}
	return
}

// ActivityLogsIDs returns the "activity_logs" edge IDs in the mutation.
func (m *UserMutation) ActivityLogsIDs() (ids []string) {
	for id := range m.activity_logs {
		ids = append(ids, id)
	}
	return
}

// ResetActivityLogs resets all changes to the "activity_logs" edge.
func (m *UserMutation) ResetActivityLogs() {
	m.activity_logs = nil
	m.clearedactivity_logs = false
	m.removedactivity_logs = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the ApiKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...string) {
	if m.api_keys == nil {
		m.api_keys = make(map[string]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the ApiKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the ApiKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the ApiKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...string) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the ApiKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []string) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []string) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// SetNotificationSettingID sets the "notification_setting" edge to the NotificationSetting entity by id.
func (m *UserMutation) SetNotificationSettingID(id string) {
	m.notification_setting = &id
}

// ClearNotificationSetting clears the "notification_setting" edge to the NotificationSetting entity.
func (m *UserMutation) ClearNotificationSetting() {
	m.clearednotification_setting = true
}

// NotificationSettingCleared reports if the "notification_setting" edge to the NotificationSetting entity was cleared.
func (m *UserMutation) NotificationSettingCleared() bool {
	return m.clearednotification_setting
}

// NotificationSettingID returns the "notification_setting" edge ID in the mutation.
func (m *UserMutation) NotificationSettingID() (id string, exists bool) {
	if m.notification_setting != nil {
		return *m.notification_setting, true
	}
	return
}

// NotificationSettingIDs returns the "notification_setting" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationSettingID instead. It exists only for internal usage by the builders.
func (m *UserMutation) NotificationSettingIDs() (ids []string) {
	if id := m.notification_setting; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotificationSetting resets all changes to the "notification_setting" edge.
func (m *UserMutation) ResetNotificationSetting() {
	m.notification_setting = nil
	m.clearednotification_setting = false
}

// AddPaymentMethodIDs adds the "payment_methods" edge to the PaymentMethod entity by ids.
func (m *UserMutation) AddPaymentMethodIDs(ids ...string) {
	if m.payment_methods == nil {
		m.payment_methods = make(map[string]struct{})
	}
	for i := range ids {
		m.payment_methods[ids[i]] = struct{}{}
	}
}

// ClearPaymentMethods clears the "payment_methods" edge to the PaymentMethod entity.
func (m *UserMutation) ClearPaymentMethods() {
	m.clearedpayment_methods = true
}

// PaymentMethodsCleared reports if the "payment_methods" edge to the PaymentMethod entity was cleared.
func (m *UserMutation) PaymentMethodsCleared() bool {
	return m.clearedpayment_methods
}

// RemovePaymentMethodIDs removes the "payment_methods" edge to the PaymentMethod entity by IDs.
func (m *UserMutation) RemovePaymentMethodIDs(ids ...string) {
	if m.removedpayment_methods == nil {
		m.removedpayment_methods = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.payment_methods, ids[i])
		m.removedpayment_methods[ids[i]] = struct{}{}
	}
}

// RemovedPaymentMethods returns the removed IDs of the "payment_methods" edge to the PaymentMethod entity.
func (m *UserMutation) RemovedPaymentMethodsIDs() (ids []string) {
	for id := range m.removedpayment_methods {
		ids = append(ids, id)
	}
	return
}

// PaymentMethodsIDs returns the "payment_methods" edge IDs in the mutation.
func (m *UserMutation) PaymentMethodsIDs() (ids []string) {
	for id := range m.payment_methods {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentMethods resets all changes to the "payment_methods" edge.
func (m *UserMutation) ResetPaymentMethods() {
	m.payment_methods = nil
	m.clearedpayment_methods = false
	m.removedpayment_methods = nil
}

// SetPrivacySettingID sets the "privacy_setting" edge to the PrivacySetting entity by id.
func (m *UserMutation) SetPrivacySettingID(id string) {
	m.privacy_setting = &id
}

// ClearPrivacySetting clears the "privacy_setting" edge to the PrivacySetting entity.
func (m *UserMutation) ClearPrivacySetting() {
	m.clearedprivacy_setting = true
}

// PrivacySettingCleared reports if the "privacy_setting" edge to the PrivacySetting entity was cleared.
func (m *UserMutation) PrivacySettingCleared() bool {
	return m.clearedprivacy_setting
}

// PrivacySettingID returns the "privacy_setting" edge ID in the mutation.
func (m *UserMutation) PrivacySettingID() (id string, exists bool) {
	if m.privacy_setting != nil {
		return *m.privacy_setting, true
	}
	return
}

// PrivacySettingIDs returns the "privacy_setting" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrivacySettingID instead. It exists only for internal usage by the builders.
func (m *UserMutation) PrivacySettingIDs() (ids []string) {
	if id := m.privacy_setting; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrivacySetting resets all changes to the "privacy_setting" edge.
func (m *UserMutation) ResetPrivacySetting() {
	m.privacy_setting = nil
	m.clearedprivacy_setting = false
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *UserMutation) AddTransactionIDs(ids ...string) {
	if m.transactions == nil {
		m.transactions = make(map[string]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *UserMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *UserMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *UserMutation) RemoveTransactionIDs(ids ...string) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *UserMutation) RemovedTransactionsIDs() (ids []string) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *UserMutation) TransactionsIDs() (ids []string) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *UserMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// SetUserProfileID sets the "user_profile" edge to the UserProfile entity by id.
func (m *UserMutation) SetUserProfileID(id string) {
	m.user_profile = &id
}

// ClearUserProfile clears the "user_profile" edge to the UserProfile entity.
func (m *UserMutation) ClearUserProfile() {
	m.cleareduser_profile = true
}

// UserProfileCleared reports if the "user_profile" edge to the UserProfile entity was cleared.
func (m *UserMutation) UserProfileCleared() bool {
	return m.cleareduser_profile
}

// UserProfileID returns the "user_profile" edge ID in the mutation.
func (m *UserMutation) UserProfileID() (id string, exists bool) {
	if m.user_profile != nil {
		return *m.user_profile, true
	}
	return
}

// UserProfileIDs returns the "user_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UserProfileIDs() (ids []string) {
	if id := m.user_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserProfile resets all changes to the "user_profile" edge.
func (m *UserMutation) ResetUserProfile() {
	m.user_profile = nil
	m.cleareduser_profile = false
}

// AddUserSessionIDs adds the "user_sessions" edge to the UserSession entity by ids.
func (m *UserMutation) AddUserSessionIDs(ids ...string) {
	if m.user_sessions == nil {
		m.user_sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.user_sessions[ids[i]] = struct{}{}
	}
}

// ClearUserSessions clears the "user_sessions" edge to the UserSession entity.
func (m *UserMutation) ClearUserSessions() {
	m.cleareduser_sessions = true
}

// UserSessionsCleared reports if the "user_sessions" edge to the UserSession entity was cleared.
func (m *UserMutation) UserSessionsCleared() bool {
	return m.cleareduser_sessions
}

// RemoveUserSessionIDs removes the "user_sessions" edge to the UserSession entity by IDs.
func (m *UserMutation) RemoveUserSessionIDs(ids ...string) {
	if m.removeduser_sessions == nil {
		m.removeduser_sessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_sessions, ids[i])
		m.removeduser_sessions[ids[i]] = struct{}{}
	}
}

// RemovedUserSessions returns the removed IDs of the "user_sessions" edge to the UserSession entity.
func (m *UserMutation) RemovedUserSessionsIDs() (ids []string) {
	for id := range m.removeduser_sessions {
		ids = append(ids, id)
	}
	return
}

// UserSessionsIDs returns the "user_sessions" edge IDs in the mutation.
func (m *UserMutation) UserSessionsIDs() (ids []string) {
	for id := range m.user_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetUserSessions resets all changes to the "user_sessions" edge.
func (m *UserMutation) ResetUserSessions() {
	m.user_sessions = nil
	m.cleareduser_sessions = false
	m.removeduser_sessions = nil
}

// AddUserTokenIDs adds the "user_tokens" edge to the UserToken entity by ids.
func (m *UserMutation) AddUserTokenIDs(ids ...string) {
	if m.user_tokens == nil {
		m.user_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.user_tokens[ids[i]] = struct{}{}
	}
}

// ClearUserTokens clears the "user_tokens" edge to the UserToken entity.
func (m *UserMutation) ClearUserTokens() {
	m.cleareduser_tokens = true
}

// UserTokensCleared reports if the "user_tokens" edge to the UserToken entity was cleared.
func (m *UserMutation) UserTokensCleared() bool {
	return m.cleareduser_tokens
}

// RemoveUserTokenIDs removes the "user_tokens" edge to the UserToken entity by IDs.
func (m *UserMutation) RemoveUserTokenIDs(ids ...string) {
	if m.removeduser_tokens == nil {
		m.removeduser_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_tokens, ids[i])
		m.removeduser_tokens[ids[i]] = struct{}{}
	}
}

// RemovedUserTokens returns the removed IDs of the "user_tokens" edge to the UserToken entity.
func (m *UserMutation) RemovedUserTokensIDs() (ids []string) {
	for id := range m.removeduser_tokens {
		ids = append(ids, id)
	}
	return
}

// UserTokensIDs returns the "user_tokens" edge IDs in the mutation.
func (m *UserMutation) UserTokensIDs() (ids []string) {
	for id := range m.user_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetUserTokens resets all changes to the "user_tokens" edge.
func (m *UserMutation) ResetUserTokens() {
	m.user_tokens = nil
	m.cleareduser_tokens = false
	m.removeduser_tokens = nil
}

// SetUser2faID sets the "user_2fa" edge to the User2fa entity by id.
func (m *UserMutation) SetUser2faID(id string) {
	m.user_2fa = &id
}

// ClearUser2fa clears the "user_2fa" edge to the User2fa entity.
func (m *UserMutation) ClearUser2fa() {
	m.cleareduser_2fa = true
}

// User2faCleared reports if the "user_2fa" edge to the User2fa entity was cleared.
func (m *UserMutation) User2faCleared() bool {
	return m.cleareduser_2fa
}

// User2faID returns the "user_2fa" edge ID in the mutation.
func (m *UserMutation) User2faID() (id string, exists bool) {
	if m.user_2fa != nil {
		return *m.user_2fa, true
	}
	return
}

// User2faIDs returns the "user_2fa" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// User2faID instead. It exists only for internal usage by the builders.
func (m *UserMutation) User2faIDs() (ids []string) {
	if id := m.user_2fa; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser2fa resets all changes to the "user_2fa" edge.
func (m *UserMutation) ResetUser2fa() {
	m.user_2fa = nil
	m.cleareduser_2fa = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.date_of_birth != nil {
		fields = append(fields, user.FieldDateOfBirth)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.phone_verified != nil {
		fields = append(fields, user.FieldPhoneVerified)
	}
	if m.account_status != nil {
		fields = append(fields, user.FieldAccountStatus)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldDateOfBirth:
		return m.DateOfBirth()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldPhoneVerified:
		return m.PhoneVerified()
	case user.FieldAccountStatus:
		return m.AccountStatus()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldPhoneVerified:
		return m.OldPhoneVerified(ctx)
	case user.FieldAccountStatus:
		return m.OldAccountStatus(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldPhoneVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneVerified(v)
		return nil
	case user.FieldAccountStatus:
		v, ok := value.(user.AccountStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountStatus(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldDateOfBirth) {
		fields = append(fields, user.FieldDateOfBirth)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldEmailVerified) {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.FieldCleared(user.FieldPhoneVerified) {
		fields = append(fields, user.FieldPhoneVerified)
	}
	if m.FieldCleared(user.FieldAccountStatus) {
		fields = append(fields, user.FieldAccountStatus)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldDateOfBirth:
		m.ClearDateOfBirth()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldEmailVerified:
		m.ClearEmailVerified()
		return nil
	case user.FieldPhoneVerified:
		m.ClearPhoneVerified()
		return nil
	case user.FieldAccountStatus:
		m.ClearAccountStatus()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldPhoneVerified:
		m.ResetPhoneVerified()
		return nil
	case user.FieldAccountStatus:
		m.ResetAccountStatus()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.activity_logs != nil {
		edges = append(edges, user.EdgeActivityLogs)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.notification_setting != nil {
		edges = append(edges, user.EdgeNotificationSetting)
	}
	if m.payment_methods != nil {
		edges = append(edges, user.EdgePaymentMethods)
	}
	if m.privacy_setting != nil {
		edges = append(edges, user.EdgePrivacySetting)
	}
	if m.transactions != nil {
		edges = append(edges, user.EdgeTransactions)
	}
	if m.user_profile != nil {
		edges = append(edges, user.EdgeUserProfile)
	}
	if m.user_sessions != nil {
		edges = append(edges, user.EdgeUserSessions)
	}
	if m.user_tokens != nil {
		edges = append(edges, user.EdgeUserTokens)
	}
	if m.user_2fa != nil {
		edges = append(edges, user.EdgeUser2fa)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeActivityLogs:
		ids := make([]ent.Value, 0, len(m.activity_logs))
		for id := range m.activity_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotificationSetting:
		if id := m.notification_setting; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePaymentMethods:
		ids := make([]ent.Value, 0, len(m.payment_methods))
		for id := range m.payment_methods {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePrivacySetting:
		if id := m.privacy_setting; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserProfile:
		if id := m.user_profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUserSessions:
		ids := make([]ent.Value, 0, len(m.user_sessions))
		for id := range m.user_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserTokens:
		ids := make([]ent.Value, 0, len(m.user_tokens))
		for id := range m.user_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUser2fa:
		if id := m.user_2fa; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedactivity_logs != nil {
		edges = append(edges, user.EdgeActivityLogs)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedpayment_methods != nil {
		edges = append(edges, user.EdgePaymentMethods)
	}
	if m.removedtransactions != nil {
		edges = append(edges, user.EdgeTransactions)
	}
	if m.removeduser_sessions != nil {
		edges = append(edges, user.EdgeUserSessions)
	}
	if m.removeduser_tokens != nil {
		edges = append(edges, user.EdgeUserTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeActivityLogs:
		ids := make([]ent.Value, 0, len(m.removedactivity_logs))
		for id := range m.removedactivity_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePaymentMethods:
		ids := make([]ent.Value, 0, len(m.removedpayment_methods))
		for id := range m.removedpayment_methods {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserSessions:
		ids := make([]ent.Value, 0, len(m.removeduser_sessions))
		for id := range m.removeduser_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserTokens:
		ids := make([]ent.Value, 0, len(m.removeduser_tokens))
		for id := range m.removeduser_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedactivity_logs {
		edges = append(edges, user.EdgeActivityLogs)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearednotification_setting {
		edges = append(edges, user.EdgeNotificationSetting)
	}
	if m.clearedpayment_methods {
		edges = append(edges, user.EdgePaymentMethods)
	}
	if m.clearedprivacy_setting {
		edges = append(edges, user.EdgePrivacySetting)
	}
	if m.clearedtransactions {
		edges = append(edges, user.EdgeTransactions)
	}
	if m.cleareduser_profile {
		edges = append(edges, user.EdgeUserProfile)
	}
	if m.cleareduser_sessions {
		edges = append(edges, user.EdgeUserSessions)
	}
	if m.cleareduser_tokens {
		edges = append(edges, user.EdgeUserTokens)
	}
	if m.cleareduser_2fa {
		edges = append(edges, user.EdgeUser2fa)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeActivityLogs:
		return m.clearedactivity_logs
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeNotificationSetting:
		return m.clearednotification_setting
	case user.EdgePaymentMethods:
		return m.clearedpayment_methods
	case user.EdgePrivacySetting:
		return m.clearedprivacy_setting
	case user.EdgeTransactions:
		return m.clearedtransactions
	case user.EdgeUserProfile:
		return m.cleareduser_profile
	case user.EdgeUserSessions:
		return m.cleareduser_sessions
	case user.EdgeUserTokens:
		return m.cleareduser_tokens
	case user.EdgeUser2fa:
		return m.cleareduser_2fa
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeNotificationSetting:
		m.ClearNotificationSetting()
		return nil
	case user.EdgePrivacySetting:
		m.ClearPrivacySetting()
		return nil
	case user.EdgeUserProfile:
		m.ClearUserProfile()
		return nil
	case user.EdgeUser2fa:
		m.ClearUser2fa()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeActivityLogs:
		m.ResetActivityLogs()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeNotificationSetting:
		m.ResetNotificationSetting()
		return nil
	case user.EdgePaymentMethods:
		m.ResetPaymentMethods()
		return nil
	case user.EdgePrivacySetting:
		m.ResetPrivacySetting()
		return nil
	case user.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case user.EdgeUserProfile:
		m.ResetUserProfile()
		return nil
	case user.EdgeUserSessions:
		m.ResetUserSessions()
		return nil
	case user.EdgeUserTokens:
		m.ResetUserTokens()
		return nil
	case user.EdgeUser2fa:
		m.ResetUser2fa()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// User2faMutation represents an operation that mutates the User2fa nodes in the graph.
type User2faMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	is_enabled         *bool
	secret_key         *string
	backup_codes       *json.RawMessage
	appendbackup_codes json.RawMessage
	method             *user2fa.Method
	phone_number       *string
	email_address      *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*User2fa, error)
	predicates         []predicate.User2fa
}

var _ ent.Mutation = (*User2faMutation)(nil)

// user2faOption allows management of the mutation configuration using functional options.
type user2faOption func(*User2faMutation)

// newUser2faMutation creates new mutation for the User2fa entity.
func newUser2faMutation(c config, op Op, opts ...user2faOption) *User2faMutation {
	m := &User2faMutation{
		config:        c,
		op:            op,
		typ:           TypeUser2fa,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUser2faID sets the ID field of the mutation.
func withUser2faID(id string) user2faOption {
	return func(m *User2faMutation) {
		var (
			err   error
			once  sync.Once
			value *User2fa
		)
		m.oldValue = func(ctx context.Context) (*User2fa, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User2fa.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser2fa sets the old User2fa of the mutation.
func withUser2fa(node *User2fa) user2faOption {
	return func(m *User2faMutation) {
		m.oldValue = func(context.Context) (*User2fa, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m User2faMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m User2faMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User2fa entities.
func (m *User2faMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *User2faMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *User2faMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User2fa.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *User2faMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *User2faMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the User2fa entity.
// If the User2fa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *User2faMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *User2faMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[user2fa.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *User2faMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[user2fa.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *User2faMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, user2fa.FieldUserID)
}

// SetIsEnabled sets the "is_enabled" field.
func (m *User2faMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *User2faMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the User2fa entity.
// If the User2fa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *User2faMutation) OldIsEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ClearIsEnabled clears the value of the "is_enabled" field.
func (m *User2faMutation) ClearIsEnabled() {
	m.is_enabled = nil
	m.clearedFields[user2fa.FieldIsEnabled] = struct{}{}
}

// IsEnabledCleared returns if the "is_enabled" field was cleared in this mutation.
func (m *User2faMutation) IsEnabledCleared() bool {
	_, ok := m.clearedFields[user2fa.FieldIsEnabled]
	return ok
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *User2faMutation) ResetIsEnabled() {
	m.is_enabled = nil
	delete(m.clearedFields, user2fa.FieldIsEnabled)
}

// SetSecretKey sets the "secret_key" field.
func (m *User2faMutation) SetSecretKey(s string) {
	m.secret_key = &s
}

// SecretKey returns the value of the "secret_key" field in the mutation.
func (m *User2faMutation) SecretKey() (r string, exists bool) {
	v := m.secret_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secret_key" field's value of the User2fa entity.
// If the User2fa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *User2faMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ClearSecretKey clears the value of the "secret_key" field.
func (m *User2faMutation) ClearSecretKey() {
	m.secret_key = nil
	m.clearedFields[user2fa.FieldSecretKey] = struct{}{}
}

// SecretKeyCleared returns if the "secret_key" field was cleared in this mutation.
func (m *User2faMutation) SecretKeyCleared() bool {
	_, ok := m.clearedFields[user2fa.FieldSecretKey]
	return ok
}

// ResetSecretKey resets all changes to the "secret_key" field.
func (m *User2faMutation) ResetSecretKey() {
	m.secret_key = nil
	delete(m.clearedFields, user2fa.FieldSecretKey)
}

// SetBackupCodes sets the "backup_codes" field.
func (m *User2faMutation) SetBackupCodes(jm json.RawMessage) {
	m.backup_codes = &jm
	m.appendbackup_codes = nil
}

// BackupCodes returns the value of the "backup_codes" field in the mutation.
func (m *User2faMutation) BackupCodes() (r json.RawMessage, exists bool) {
	v := m.backup_codes
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupCodes returns the old "backup_codes" field's value of the User2fa entity.
// If the User2fa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *User2faMutation) OldBackupCodes(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupCodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupCodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupCodes: %w", err)
	}
	return oldValue.BackupCodes, nil
}

// AppendBackupCodes adds jm to the "backup_codes" field.
func (m *User2faMutation) AppendBackupCodes(jm json.RawMessage) {
	m.appendbackup_codes = append(m.appendbackup_codes, jm...)
}

// AppendedBackupCodes returns the list of values that were appended to the "backup_codes" field in this mutation.
func (m *User2faMutation) AppendedBackupCodes() (json.RawMessage, bool) {
	if len(m.appendbackup_codes) == 0 {
		return nil, false
	}
	return m.appendbackup_codes, true
}

// ClearBackupCodes clears the value of the "backup_codes" field.
func (m *User2faMutation) ClearBackupCodes() {
	m.backup_codes = nil
	m.appendbackup_codes = nil
	m.clearedFields[user2fa.FieldBackupCodes] = struct{}{}
}

// BackupCodesCleared returns if the "backup_codes" field was cleared in this mutation.
func (m *User2faMutation) BackupCodesCleared() bool {
	_, ok := m.clearedFields[user2fa.FieldBackupCodes]
	return ok
}

// ResetBackupCodes resets all changes to the "backup_codes" field.
func (m *User2faMutation) ResetBackupCodes() {
	m.backup_codes = nil
	m.appendbackup_codes = nil
	delete(m.clearedFields, user2fa.FieldBackupCodes)
}

// SetMethod sets the "method" field.
func (m *User2faMutation) SetMethod(u user2fa.Method) {
	m.method = &u
}

// Method returns the value of the "method" field in the mutation.
func (m *User2faMutation) Method() (r user2fa.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the User2fa entity.
// If the User2fa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *User2faMutation) OldMethod(ctx context.Context) (v user2fa.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *User2faMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[user2fa.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *User2faMutation) MethodCleared() bool {
	_, ok := m.clearedFields[user2fa.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *User2faMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, user2fa.FieldMethod)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *User2faMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *User2faMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User2fa entity.
// If the User2fa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *User2faMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *User2faMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user2fa.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *User2faMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user2fa.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *User2faMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user2fa.FieldPhoneNumber)
}

// SetEmailAddress sets the "email_address" field.
func (m *User2faMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *User2faMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the User2fa entity.
// If the User2fa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *User2faMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ClearEmailAddress clears the value of the "email_address" field.
func (m *User2faMutation) ClearEmailAddress() {
	m.email_address = nil
	m.clearedFields[user2fa.FieldEmailAddress] = struct{}{}
}

// EmailAddressCleared returns if the "email_address" field was cleared in this mutation.
func (m *User2faMutation) EmailAddressCleared() bool {
	_, ok := m.clearedFields[user2fa.FieldEmailAddress]
	return ok
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *User2faMutation) ResetEmailAddress() {
	m.email_address = nil
	delete(m.clearedFields, user2fa.FieldEmailAddress)
}

// SetCreatedAt sets the "created_at" field.
func (m *User2faMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *User2faMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User2fa entity.
// If the User2fa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *User2faMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *User2faMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user2fa.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *User2faMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user2fa.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *User2faMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user2fa.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *User2faMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *User2faMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User2fa entity.
// If the User2fa object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *User2faMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *User2faMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user2fa.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *User2faMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user2fa.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *User2faMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user2fa.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *User2faMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[user2fa.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *User2faMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *User2faMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *User2faMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the User2faMutation builder.
func (m *User2faMutation) Where(ps ...predicate.User2fa) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the User2faMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *User2faMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User2fa, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *User2faMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *User2faMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User2fa).
func (m *User2faMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *User2faMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user != nil {
		fields = append(fields, user2fa.FieldUserID)
	}
	if m.is_enabled != nil {
		fields = append(fields, user2fa.FieldIsEnabled)
	}
	if m.secret_key != nil {
		fields = append(fields, user2fa.FieldSecretKey)
	}
	if m.backup_codes != nil {
		fields = append(fields, user2fa.FieldBackupCodes)
	}
	if m.method != nil {
		fields = append(fields, user2fa.FieldMethod)
	}
	if m.phone_number != nil {
		fields = append(fields, user2fa.FieldPhoneNumber)
	}
	if m.email_address != nil {
		fields = append(fields, user2fa.FieldEmailAddress)
	}
	if m.created_at != nil {
		fields = append(fields, user2fa.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user2fa.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *User2faMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user2fa.FieldUserID:
		return m.UserID()
	case user2fa.FieldIsEnabled:
		return m.IsEnabled()
	case user2fa.FieldSecretKey:
		return m.SecretKey()
	case user2fa.FieldBackupCodes:
		return m.BackupCodes()
	case user2fa.FieldMethod:
		return m.Method()
	case user2fa.FieldPhoneNumber:
		return m.PhoneNumber()
	case user2fa.FieldEmailAddress:
		return m.EmailAddress()
	case user2fa.FieldCreatedAt:
		return m.CreatedAt()
	case user2fa.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *User2faMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user2fa.FieldUserID:
		return m.OldUserID(ctx)
	case user2fa.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	case user2fa.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case user2fa.FieldBackupCodes:
		return m.OldBackupCodes(ctx)
	case user2fa.FieldMethod:
		return m.OldMethod(ctx)
	case user2fa.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user2fa.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case user2fa.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user2fa.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User2fa field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *User2faMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user2fa.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case user2fa.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	case user2fa.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case user2fa.FieldBackupCodes:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupCodes(v)
		return nil
	case user2fa.FieldMethod:
		v, ok := value.(user2fa.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case user2fa.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user2fa.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case user2fa.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user2fa.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User2fa field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *User2faMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *User2faMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *User2faMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User2fa numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *User2faMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user2fa.FieldUserID) {
		fields = append(fields, user2fa.FieldUserID)
	}
	if m.FieldCleared(user2fa.FieldIsEnabled) {
		fields = append(fields, user2fa.FieldIsEnabled)
	}
	if m.FieldCleared(user2fa.FieldSecretKey) {
		fields = append(fields, user2fa.FieldSecretKey)
	}
	if m.FieldCleared(user2fa.FieldBackupCodes) {
		fields = append(fields, user2fa.FieldBackupCodes)
	}
	if m.FieldCleared(user2fa.FieldMethod) {
		fields = append(fields, user2fa.FieldMethod)
	}
	if m.FieldCleared(user2fa.FieldPhoneNumber) {
		fields = append(fields, user2fa.FieldPhoneNumber)
	}
	if m.FieldCleared(user2fa.FieldEmailAddress) {
		fields = append(fields, user2fa.FieldEmailAddress)
	}
	if m.FieldCleared(user2fa.FieldCreatedAt) {
		fields = append(fields, user2fa.FieldCreatedAt)
	}
	if m.FieldCleared(user2fa.FieldUpdatedAt) {
		fields = append(fields, user2fa.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *User2faMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *User2faMutation) ClearField(name string) error {
	switch name {
	case user2fa.FieldUserID:
		m.ClearUserID()
		return nil
	case user2fa.FieldIsEnabled:
		m.ClearIsEnabled()
		return nil
	case user2fa.FieldSecretKey:
		m.ClearSecretKey()
		return nil
	case user2fa.FieldBackupCodes:
		m.ClearBackupCodes()
		return nil
	case user2fa.FieldMethod:
		m.ClearMethod()
		return nil
	case user2fa.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user2fa.FieldEmailAddress:
		m.ClearEmailAddress()
		return nil
	case user2fa.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user2fa.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User2fa nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *User2faMutation) ResetField(name string) error {
	switch name {
	case user2fa.FieldUserID:
		m.ResetUserID()
		return nil
	case user2fa.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	case user2fa.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case user2fa.FieldBackupCodes:
		m.ResetBackupCodes()
		return nil
	case user2fa.FieldMethod:
		m.ResetMethod()
		return nil
	case user2fa.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user2fa.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case user2fa.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user2fa.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User2fa field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *User2faMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, user2fa.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *User2faMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user2fa.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *User2faMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *User2faMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *User2faMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, user2fa.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *User2faMutation) EdgeCleared(name string) bool {
	switch name {
	case user2fa.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *User2faMutation) ClearEdge(name string) error {
	switch name {
	case user2fa.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown User2fa unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *User2faMutation) ResetEdge(name string) error {
	switch name {
	case user2fa.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown User2fa edge %s", name)
}

// UserProfileMutation represents an operation that mutates the UserProfile nodes in the graph.
type UserProfileMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	bio                *string
	website            *string
	location           *string
	timezone           *string
	language           *string
	gender             *userprofile.Gender
	profile_visibility *userprofile.ProfileVisibility
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*UserProfile, error)
	predicates         []predicate.UserProfile
}

var _ ent.Mutation = (*UserProfileMutation)(nil)

// userprofileOption allows management of the mutation configuration using functional options.
type userprofileOption func(*UserProfileMutation)

// newUserProfileMutation creates new mutation for the UserProfile entity.
func newUserProfileMutation(c config, op Op, opts ...userprofileOption) *UserProfileMutation {
	m := &UserProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProfileID sets the ID field of the mutation.
func withUserProfileID(id string) userprofileOption {
	return func(m *UserProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProfile
		)
		m.oldValue = func(ctx context.Context) (*UserProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProfile sets the old UserProfile of the mutation.
func withUserProfile(node *UserProfile) userprofileOption {
	return func(m *UserProfileMutation) {
		m.oldValue = func(context.Context) (*UserProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserProfile entities.
func (m *UserProfileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProfileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProfileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserProfileMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProfileMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserProfileMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userprofile.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserProfileMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProfileMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userprofile.FieldUserID)
}

// SetBio sets the "bio" field.
func (m *UserProfileMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserProfileMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserProfileMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[userprofile.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserProfileMutation) BioCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserProfileMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, userprofile.FieldBio)
}

// SetWebsite sets the "website" field.
func (m *UserProfileMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *UserProfileMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *UserProfileMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[userprofile.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *UserProfileMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *UserProfileMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, userprofile.FieldWebsite)
}

// SetLocation sets the "location" field.
func (m *UserProfileMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UserProfileMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *UserProfileMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[userprofile.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *UserProfileMutation) LocationCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *UserProfileMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, userprofile.FieldLocation)
}

// SetTimezone sets the "timezone" field.
func (m *UserProfileMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *UserProfileMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *UserProfileMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[userprofile.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *UserProfileMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *UserProfileMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, userprofile.FieldTimezone)
}

// SetLanguage sets the "language" field.
func (m *UserProfileMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *UserProfileMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *UserProfileMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[userprofile.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *UserProfileMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *UserProfileMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, userprofile.FieldLanguage)
}

// SetGender sets the "gender" field.
func (m *UserProfileMutation) SetGender(u userprofile.Gender) {
	m.gender = &u
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserProfileMutation) Gender() (r userprofile.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldGender(ctx context.Context) (v userprofile.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *UserProfileMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[userprofile.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *UserProfileMutation) GenderCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *UserProfileMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, userprofile.FieldGender)
}

// SetProfileVisibility sets the "profile_visibility" field.
func (m *UserProfileMutation) SetProfileVisibility(uv userprofile.ProfileVisibility) {
	m.profile_visibility = &uv
}

// ProfileVisibility returns the value of the "profile_visibility" field in the mutation.
func (m *UserProfileMutation) ProfileVisibility() (r userprofile.ProfileVisibility, exists bool) {
	v := m.profile_visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileVisibility returns the old "profile_visibility" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldProfileVisibility(ctx context.Context) (v userprofile.ProfileVisibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileVisibility: %w", err)
	}
	return oldValue.ProfileVisibility, nil
}

// ClearProfileVisibility clears the value of the "profile_visibility" field.
func (m *UserProfileMutation) ClearProfileVisibility() {
	m.profile_visibility = nil
	m.clearedFields[userprofile.FieldProfileVisibility] = struct{}{}
}

// ProfileVisibilityCleared returns if the "profile_visibility" field was cleared in this mutation.
func (m *UserProfileMutation) ProfileVisibilityCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldProfileVisibility]
	return ok
}

// ResetProfileVisibility resets all changes to the "profile_visibility" field.
func (m *UserProfileMutation) ResetProfileVisibility() {
	m.profile_visibility = nil
	delete(m.clearedFields, userprofile.FieldProfileVisibility)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserProfileMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userprofile.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserProfileMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProfileMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userprofile.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserProfileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userprofile.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserProfileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userprofile.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProfileMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userprofile.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProfileMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserProfileMutation builder.
func (m *UserProfileMutation) Where(ps ...predicate.UserProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProfile).
func (m *UserProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProfileMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.user != nil {
		fields = append(fields, userprofile.FieldUserID)
	}
	if m.bio != nil {
		fields = append(fields, userprofile.FieldBio)
	}
	if m.website != nil {
		fields = append(fields, userprofile.FieldWebsite)
	}
	if m.location != nil {
		fields = append(fields, userprofile.FieldLocation)
	}
	if m.timezone != nil {
		fields = append(fields, userprofile.FieldTimezone)
	}
	if m.language != nil {
		fields = append(fields, userprofile.FieldLanguage)
	}
	if m.gender != nil {
		fields = append(fields, userprofile.FieldGender)
	}
	if m.profile_visibility != nil {
		fields = append(fields, userprofile.FieldProfileVisibility)
	}
	if m.created_at != nil {
		fields = append(fields, userprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userprofile.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldUserID:
		return m.UserID()
	case userprofile.FieldBio:
		return m.Bio()
	case userprofile.FieldWebsite:
		return m.Website()
	case userprofile.FieldLocation:
		return m.Location()
	case userprofile.FieldTimezone:
		return m.Timezone()
	case userprofile.FieldLanguage:
		return m.Language()
	case userprofile.FieldGender:
		return m.Gender()
	case userprofile.FieldProfileVisibility:
		return m.ProfileVisibility()
	case userprofile.FieldCreatedAt:
		return m.CreatedAt()
	case userprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userprofile.FieldUserID:
		return m.OldUserID(ctx)
	case userprofile.FieldBio:
		return m.OldBio(ctx)
	case userprofile.FieldWebsite:
		return m.OldWebsite(ctx)
	case userprofile.FieldLocation:
		return m.OldLocation(ctx)
	case userprofile.FieldTimezone:
		return m.OldTimezone(ctx)
	case userprofile.FieldLanguage:
		return m.OldLanguage(ctx)
	case userprofile.FieldGender:
		return m.OldGender(ctx)
	case userprofile.FieldProfileVisibility:
		return m.OldProfileVisibility(ctx)
	case userprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userprofile.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case userprofile.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case userprofile.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case userprofile.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case userprofile.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case userprofile.FieldGender:
		v, ok := value.(userprofile.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case userprofile.FieldProfileVisibility:
		v, ok := value.(userprofile.ProfileVisibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileVisibility(v)
		return nil
	case userprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userprofile.FieldUserID) {
		fields = append(fields, userprofile.FieldUserID)
	}
	if m.FieldCleared(userprofile.FieldBio) {
		fields = append(fields, userprofile.FieldBio)
	}
	if m.FieldCleared(userprofile.FieldWebsite) {
		fields = append(fields, userprofile.FieldWebsite)
	}
	if m.FieldCleared(userprofile.FieldLocation) {
		fields = append(fields, userprofile.FieldLocation)
	}
	if m.FieldCleared(userprofile.FieldTimezone) {
		fields = append(fields, userprofile.FieldTimezone)
	}
	if m.FieldCleared(userprofile.FieldLanguage) {
		fields = append(fields, userprofile.FieldLanguage)
	}
	if m.FieldCleared(userprofile.FieldGender) {
		fields = append(fields, userprofile.FieldGender)
	}
	if m.FieldCleared(userprofile.FieldProfileVisibility) {
		fields = append(fields, userprofile.FieldProfileVisibility)
	}
	if m.FieldCleared(userprofile.FieldCreatedAt) {
		fields = append(fields, userprofile.FieldCreatedAt)
	}
	if m.FieldCleared(userprofile.FieldUpdatedAt) {
		fields = append(fields, userprofile.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProfileMutation) ClearField(name string) error {
	switch name {
	case userprofile.FieldUserID:
		m.ClearUserID()
		return nil
	case userprofile.FieldBio:
		m.ClearBio()
		return nil
	case userprofile.FieldWebsite:
		m.ClearWebsite()
		return nil
	case userprofile.FieldLocation:
		m.ClearLocation()
		return nil
	case userprofile.FieldTimezone:
		m.ClearTimezone()
		return nil
	case userprofile.FieldLanguage:
		m.ClearLanguage()
		return nil
	case userprofile.FieldGender:
		m.ClearGender()
		return nil
	case userprofile.FieldProfileVisibility:
		m.ClearProfileVisibility()
		return nil
	case userprofile.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userprofile.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProfileMutation) ResetField(name string) error {
	switch name {
	case userprofile.FieldUserID:
		m.ResetUserID()
		return nil
	case userprofile.FieldBio:
		m.ResetBio()
		return nil
	case userprofile.FieldWebsite:
		m.ResetWebsite()
		return nil
	case userprofile.FieldLocation:
		m.ResetLocation()
		return nil
	case userprofile.FieldTimezone:
		m.ResetTimezone()
		return nil
	case userprofile.FieldLanguage:
		m.ResetLanguage()
		return nil
	case userprofile.FieldGender:
		m.ResetGender()
		return nil
	case userprofile.FieldProfileVisibility:
		m.ResetProfileVisibility()
		return nil
	case userprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userprofile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userprofile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userprofile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProfileMutation) ClearEdge(name string) error {
	switch name {
	case userprofile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProfileMutation) ResetEdge(name string) error {
	switch name {
	case userprofile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserProfile edge %s", name)
}

// UserSessionMutation represents an operation that mutates the UserSession nodes in the graph.
type UserSessionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	session_token *string
	device_info   *string
	ip_address    *string
	user_agent    *string
	is_active     *bool
	expires_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserSession, error)
	predicates    []predicate.UserSession
}

var _ ent.Mutation = (*UserSessionMutation)(nil)

// usersessionOption allows management of the mutation configuration using functional options.
type usersessionOption func(*UserSessionMutation)

// newUserSessionMutation creates new mutation for the UserSession entity.
func newUserSessionMutation(c config, op Op, opts ...usersessionOption) *UserSessionMutation {
	m := &UserSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSessionID sets the ID field of the mutation.
func withUserSessionID(id string) usersessionOption {
	return func(m *UserSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSession
		)
		m.oldValue = func(ctx context.Context) (*UserSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSession sets the old UserSession of the mutation.
func withUserSession(node *UserSession) usersessionOption {
	return func(m *UserSessionMutation) {
		m.oldValue = func(context.Context) (*UserSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSession entities.
func (m *UserSessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserSessionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSessionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserSessionMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[usersession.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserSessionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usersession.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSessionMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, usersession.FieldUserID)
}

// SetSessionToken sets the "session_token" field.
func (m *UserSessionMutation) SetSessionToken(s string) {
	m.session_token = &s
}

// SessionToken returns the value of the "session_token" field in the mutation.
func (m *UserSessionMutation) SessionToken() (r string, exists bool) {
	v := m.session_token
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionToken returns the old "session_token" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldSessionToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionToken: %w", err)
	}
	return oldValue.SessionToken, nil
}

// ResetSessionToken resets all changes to the "session_token" field.
func (m *UserSessionMutation) ResetSessionToken() {
	m.session_token = nil
}

// SetDeviceInfo sets the "device_info" field.
func (m *UserSessionMutation) SetDeviceInfo(s string) {
	m.device_info = &s
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *UserSessionMutation) DeviceInfo() (r string, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldDeviceInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *UserSessionMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[usersession.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *UserSessionMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[usersession.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *UserSessionMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, usersession.FieldDeviceInfo)
}

// SetIPAddress sets the "ip_address" field.
func (m *UserSessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UserSessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *UserSessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[usersession.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *UserSessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[usersession.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UserSessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, usersession.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *UserSessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UserSessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UserSessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[usersession.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UserSessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[usersession.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UserSessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, usersession.FieldUserAgent)
}

// SetIsActive sets the "is_active" field.
func (m *UserSessionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserSessionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ClearIsActive clears the value of the "is_active" field.
func (m *UserSessionMutation) ClearIsActive() {
	m.is_active = nil
	m.clearedFields[usersession.FieldIsActive] = struct{}{}
}

// IsActiveCleared returns if the "is_active" field was cleared in this mutation.
func (m *UserSessionMutation) IsActiveCleared() bool {
	_, ok := m.clearedFields[usersession.FieldIsActive]
	return ok
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserSessionMutation) ResetIsActive() {
	m.is_active = nil
	delete(m.clearedFields, usersession.FieldIsActive)
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserSessionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[usersession.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserSessionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usersession.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSessionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, usersession.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserSessionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[usersession.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserSessionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usersession.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, usersession.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usersession.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSessionMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSessionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserSessionMutation builder.
func (m *UserSessionMutation) Where(ps ...predicate.UserSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSession).
func (m *UserSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSessionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user != nil {
		fields = append(fields, usersession.FieldUserID)
	}
	if m.session_token != nil {
		fields = append(fields, usersession.FieldSessionToken)
	}
	if m.device_info != nil {
		fields = append(fields, usersession.FieldDeviceInfo)
	}
	if m.ip_address != nil {
		fields = append(fields, usersession.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, usersession.FieldUserAgent)
	}
	if m.is_active != nil {
		fields = append(fields, usersession.FieldIsActive)
	}
	if m.expires_at != nil {
		fields = append(fields, usersession.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, usersession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersession.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersession.FieldUserID:
		return m.UserID()
	case usersession.FieldSessionToken:
		return m.SessionToken()
	case usersession.FieldDeviceInfo:
		return m.DeviceInfo()
	case usersession.FieldIPAddress:
		return m.IPAddress()
	case usersession.FieldUserAgent:
		return m.UserAgent()
	case usersession.FieldIsActive:
		return m.IsActive()
	case usersession.FieldExpiresAt:
		return m.ExpiresAt()
	case usersession.FieldCreatedAt:
		return m.CreatedAt()
	case usersession.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersession.FieldUserID:
		return m.OldUserID(ctx)
	case usersession.FieldSessionToken:
		return m.OldSessionToken(ctx)
	case usersession.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	case usersession.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case usersession.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case usersession.FieldIsActive:
		return m.OldIsActive(ctx)
	case usersession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case usersession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersession.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersession.FieldSessionToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionToken(v)
		return nil
	case usersession.FieldDeviceInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	case usersession.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case usersession.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case usersession.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case usersession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case usersession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersession.FieldUserID) {
		fields = append(fields, usersession.FieldUserID)
	}
	if m.FieldCleared(usersession.FieldDeviceInfo) {
		fields = append(fields, usersession.FieldDeviceInfo)
	}
	if m.FieldCleared(usersession.FieldIPAddress) {
		fields = append(fields, usersession.FieldIPAddress)
	}
	if m.FieldCleared(usersession.FieldUserAgent) {
		fields = append(fields, usersession.FieldUserAgent)
	}
	if m.FieldCleared(usersession.FieldIsActive) {
		fields = append(fields, usersession.FieldIsActive)
	}
	if m.FieldCleared(usersession.FieldCreatedAt) {
		fields = append(fields, usersession.FieldCreatedAt)
	}
	if m.FieldCleared(usersession.FieldUpdatedAt) {
		fields = append(fields, usersession.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSessionMutation) ClearField(name string) error {
	switch name {
	case usersession.FieldUserID:
		m.ClearUserID()
		return nil
	case usersession.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case usersession.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case usersession.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case usersession.FieldIsActive:
		m.ClearIsActive()
		return nil
	case usersession.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usersession.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSessionMutation) ResetField(name string) error {
	switch name {
	case usersession.FieldUserID:
		m.ResetUserID()
		return nil
	case usersession.FieldSessionToken:
		m.ResetSessionToken()
		return nil
	case usersession.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case usersession.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case usersession.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case usersession.FieldIsActive:
		m.ResetIsActive()
		return nil
	case usersession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case usersession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usersession.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usersession.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersession.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSessionMutation) ClearEdge(name string) error {
	switch name {
	case usersession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSessionMutation) ResetEdge(name string) error {
	switch name {
	case usersession.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserSession edge %s", name)
}

// UserTokenMutation represents an operation that mutates the UserToken nodes in the graph.
type UserTokenMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	token_type               *usertoken.TokenType
	token_hash               *string
	jti                      *string
	expires_at               *time.Time
	is_revoked               *bool
	device_info              *string
	ip_address               *string
	user_agent               *string
	created_at               *time.Time
	revoked_at               *time.Time
	last_used_at             *time.Time
	clearedFields            map[string]struct{}
	user                     *string
	cleareduser              bool
	child_user_tokens        map[string]struct{}
	removedchild_user_tokens map[string]struct{}
	clearedchild_user_tokens bool
	parent_user_token        *string
	clearedparent_user_token bool
	done                     bool
	oldValue                 func(context.Context) (*UserToken, error)
	predicates               []predicate.UserToken
}

var _ ent.Mutation = (*UserTokenMutation)(nil)

// usertokenOption allows management of the mutation configuration using functional options.
type usertokenOption func(*UserTokenMutation)

// newUserTokenMutation creates new mutation for the UserToken entity.
func newUserTokenMutation(c config, op Op, opts ...usertokenOption) *UserTokenMutation {
	m := &UserTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeUserToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserTokenID sets the ID field of the mutation.
func withUserTokenID(id string) usertokenOption {
	return func(m *UserTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *UserToken
		)
		m.oldValue = func(ctx context.Context) (*UserToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserToken sets the old UserToken of the mutation.
func withUserToken(node *UserToken) usertokenOption {
	return func(m *UserTokenMutation) {
		m.oldValue = func(context.Context) (*UserToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserToken entities.
func (m *UserTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserTokenMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserTokenMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserTokenMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[usertoken.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserTokenMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserTokenMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, usertoken.FieldUserID)
}

// SetTokenType sets the "token_type" field.
func (m *UserTokenMutation) SetTokenType(ut usertoken.TokenType) {
	m.token_type = &ut
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *UserTokenMutation) TokenType() (r usertoken.TokenType, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldTokenType(ctx context.Context) (v usertoken.TokenType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *UserTokenMutation) ResetTokenType() {
	m.token_type = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *UserTokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *UserTokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *UserTokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetJti sets the "jti" field.
func (m *UserTokenMutation) SetJti(s string) {
	m.jti = &s
}

// Jti returns the value of the "jti" field in the mutation.
func (m *UserTokenMutation) Jti() (r string, exists bool) {
	v := m.jti
	if v == nil {
		return
	}
	return *v, true
}

// OldJti returns the old "jti" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldJti(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJti is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJti requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJti: %w", err)
	}
	return oldValue.Jti, nil
}

// ResetJti resets all changes to the "jti" field.
func (m *UserTokenMutation) ResetJti() {
	m.jti = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIsRevoked sets the "is_revoked" field.
func (m *UserTokenMutation) SetIsRevoked(b bool) {
	m.is_revoked = &b
}

// IsRevoked returns the value of the "is_revoked" field in the mutation.
func (m *UserTokenMutation) IsRevoked() (r bool, exists bool) {
	v := m.is_revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRevoked returns the old "is_revoked" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldIsRevoked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRevoked: %w", err)
	}
	return oldValue.IsRevoked, nil
}

// ClearIsRevoked clears the value of the "is_revoked" field.
func (m *UserTokenMutation) ClearIsRevoked() {
	m.is_revoked = nil
	m.clearedFields[usertoken.FieldIsRevoked] = struct{}{}
}

// IsRevokedCleared returns if the "is_revoked" field was cleared in this mutation.
func (m *UserTokenMutation) IsRevokedCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldIsRevoked]
	return ok
}

// ResetIsRevoked resets all changes to the "is_revoked" field.
func (m *UserTokenMutation) ResetIsRevoked() {
	m.is_revoked = nil
	delete(m.clearedFields, usertoken.FieldIsRevoked)
}

// SetDeviceInfo sets the "device_info" field.
func (m *UserTokenMutation) SetDeviceInfo(s string) {
	m.device_info = &s
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *UserTokenMutation) DeviceInfo() (r string, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldDeviceInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *UserTokenMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[usertoken.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *UserTokenMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *UserTokenMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, usertoken.FieldDeviceInfo)
}

// SetIPAddress sets the "ip_address" field.
func (m *UserTokenMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UserTokenMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *UserTokenMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[usertoken.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *UserTokenMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UserTokenMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, usertoken.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *UserTokenMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UserTokenMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UserTokenMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[usertoken.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UserTokenMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UserTokenMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, usertoken.FieldUserAgent)
}

// SetParentTokenID sets the "parent_token_id" field.
func (m *UserTokenMutation) SetParentTokenID(s string) {
	m.parent_user_token = &s
}

// ParentTokenID returns the value of the "parent_token_id" field in the mutation.
func (m *UserTokenMutation) ParentTokenID() (r string, exists bool) {
	v := m.parent_user_token
	if v == nil {
		return
	}
	return *v, true
}

// OldParentTokenID returns the old "parent_token_id" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldParentTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentTokenID: %w", err)
	}
	return oldValue.ParentTokenID, nil
}

// ClearParentTokenID clears the value of the "parent_token_id" field.
func (m *UserTokenMutation) ClearParentTokenID() {
	m.parent_user_token = nil
	m.clearedFields[usertoken.FieldParentTokenID] = struct{}{}
}

// ParentTokenIDCleared returns if the "parent_token_id" field was cleared in this mutation.
func (m *UserTokenMutation) ParentTokenIDCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldParentTokenID]
	return ok
}

// ResetParentTokenID resets all changes to the "parent_token_id" field.
func (m *UserTokenMutation) ResetParentTokenID() {
	m.parent_user_token = nil
	delete(m.clearedFields, usertoken.FieldParentTokenID)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserTokenMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[usertoken.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserTokenMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserTokenMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, usertoken.FieldCreatedAt)
}

// SetRevokedAt sets the "revoked_at" field.
func (m *UserTokenMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *UserTokenMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldRevokedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *UserTokenMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[usertoken.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *UserTokenMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *UserTokenMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, usertoken.FieldRevokedAt)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *UserTokenMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *UserTokenMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *UserTokenMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[usertoken.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *UserTokenMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *UserTokenMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, usertoken.FieldLastUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usertoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserTokenMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserTokenMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddChildUserTokenIDs adds the "child_user_tokens" edge to the UserToken entity by ids.
func (m *UserTokenMutation) AddChildUserTokenIDs(ids ...string) {
	if m.child_user_tokens == nil {
		m.child_user_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.child_user_tokens[ids[i]] = struct{}{}
	}
}

// ClearChildUserTokens clears the "child_user_tokens" edge to the UserToken entity.
func (m *UserTokenMutation) ClearChildUserTokens() {
	m.clearedchild_user_tokens = true
}

// ChildUserTokensCleared reports if the "child_user_tokens" edge to the UserToken entity was cleared.
func (m *UserTokenMutation) ChildUserTokensCleared() bool {
	return m.clearedchild_user_tokens
}

// RemoveChildUserTokenIDs removes the "child_user_tokens" edge to the UserToken entity by IDs.
func (m *UserTokenMutation) RemoveChildUserTokenIDs(ids ...string) {
	if m.removedchild_user_tokens == nil {
		m.removedchild_user_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.child_user_tokens, ids[i])
		m.removedchild_user_tokens[ids[i]] = struct{}{}
	}
}

// RemovedChildUserTokens returns the removed IDs of the "child_user_tokens" edge to the UserToken entity.
func (m *UserTokenMutation) RemovedChildUserTokensIDs() (ids []string) {
	for id := range m.removedchild_user_tokens {
		ids = append(ids, id)
	}
	return
}

// ChildUserTokensIDs returns the "child_user_tokens" edge IDs in the mutation.
func (m *UserTokenMutation) ChildUserTokensIDs() (ids []string) {
	for id := range m.child_user_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetChildUserTokens resets all changes to the "child_user_tokens" edge.
func (m *UserTokenMutation) ResetChildUserTokens() {
	m.child_user_tokens = nil
	m.clearedchild_user_tokens = false
	m.removedchild_user_tokens = nil
}

// SetParentUserTokenID sets the "parent_user_token" edge to the UserToken entity by id.
func (m *UserTokenMutation) SetParentUserTokenID(id string) {
	m.parent_user_token = &id
}

// ClearParentUserToken clears the "parent_user_token" edge to the UserToken entity.
func (m *UserTokenMutation) ClearParentUserToken() {
	m.clearedparent_user_token = true
	m.clearedFields[usertoken.FieldParentTokenID] = struct{}{}
}

// ParentUserTokenCleared reports if the "parent_user_token" edge to the UserToken entity was cleared.
func (m *UserTokenMutation) ParentUserTokenCleared() bool {
	return m.ParentTokenIDCleared() || m.clearedparent_user_token
}

// ParentUserTokenID returns the "parent_user_token" edge ID in the mutation.
func (m *UserTokenMutation) ParentUserTokenID() (id string, exists bool) {
	if m.parent_user_token != nil {
		return *m.parent_user_token, true
	}
	return
}

// ParentUserTokenIDs returns the "parent_user_token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentUserTokenID instead. It exists only for internal usage by the builders.
func (m *UserTokenMutation) ParentUserTokenIDs() (ids []string) {
	if id := m.parent_user_token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentUserToken resets all changes to the "parent_user_token" edge.
func (m *UserTokenMutation) ResetParentUserToken() {
	m.parent_user_token = nil
	m.clearedparent_user_token = false
}

// Where appends a list predicates to the UserTokenMutation builder.
func (m *UserTokenMutation) Where(ps ...predicate.UserToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserToken).
func (m *UserTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserTokenMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, usertoken.FieldUserID)
	}
	if m.token_type != nil {
		fields = append(fields, usertoken.FieldTokenType)
	}
	if m.token_hash != nil {
		fields = append(fields, usertoken.FieldTokenHash)
	}
	if m.jti != nil {
		fields = append(fields, usertoken.FieldJti)
	}
	if m.expires_at != nil {
		fields = append(fields, usertoken.FieldExpiresAt)
	}
	if m.is_revoked != nil {
		fields = append(fields, usertoken.FieldIsRevoked)
	}
	if m.device_info != nil {
		fields = append(fields, usertoken.FieldDeviceInfo)
	}
	if m.ip_address != nil {
		fields = append(fields, usertoken.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, usertoken.FieldUserAgent)
	}
	if m.parent_user_token != nil {
		fields = append(fields, usertoken.FieldParentTokenID)
	}
	if m.created_at != nil {
		fields = append(fields, usertoken.FieldCreatedAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, usertoken.FieldRevokedAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, usertoken.FieldLastUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usertoken.FieldUserID:
		return m.UserID()
	case usertoken.FieldTokenType:
		return m.TokenType()
	case usertoken.FieldTokenHash:
		return m.TokenHash()
	case usertoken.FieldJti:
		return m.Jti()
	case usertoken.FieldExpiresAt:
		return m.ExpiresAt()
	case usertoken.FieldIsRevoked:
		return m.IsRevoked()
	case usertoken.FieldDeviceInfo:
		return m.DeviceInfo()
	case usertoken.FieldIPAddress:
		return m.IPAddress()
	case usertoken.FieldUserAgent:
		return m.UserAgent()
	case usertoken.FieldParentTokenID:
		return m.ParentTokenID()
	case usertoken.FieldCreatedAt:
		return m.CreatedAt()
	case usertoken.FieldRevokedAt:
		return m.RevokedAt()
	case usertoken.FieldLastUsedAt:
		return m.LastUsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usertoken.FieldUserID:
		return m.OldUserID(ctx)
	case usertoken.FieldTokenType:
		return m.OldTokenType(ctx)
	case usertoken.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case usertoken.FieldJti:
		return m.OldJti(ctx)
	case usertoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case usertoken.FieldIsRevoked:
		return m.OldIsRevoked(ctx)
	case usertoken.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	case usertoken.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case usertoken.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case usertoken.FieldParentTokenID:
		return m.OldParentTokenID(ctx)
	case usertoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usertoken.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case usertoken.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usertoken.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usertoken.FieldTokenType:
		v, ok := value.(usertoken.TokenType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case usertoken.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case usertoken.FieldJti:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJti(v)
		return nil
	case usertoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case usertoken.FieldIsRevoked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRevoked(v)
		return nil
	case usertoken.FieldDeviceInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	case usertoken.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case usertoken.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case usertoken.FieldParentTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentTokenID(v)
		return nil
	case usertoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usertoken.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case usertoken.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usertoken.FieldUserID) {
		fields = append(fields, usertoken.FieldUserID)
	}
	if m.FieldCleared(usertoken.FieldIsRevoked) {
		fields = append(fields, usertoken.FieldIsRevoked)
	}
	if m.FieldCleared(usertoken.FieldDeviceInfo) {
		fields = append(fields, usertoken.FieldDeviceInfo)
	}
	if m.FieldCleared(usertoken.FieldIPAddress) {
		fields = append(fields, usertoken.FieldIPAddress)
	}
	if m.FieldCleared(usertoken.FieldUserAgent) {
		fields = append(fields, usertoken.FieldUserAgent)
	}
	if m.FieldCleared(usertoken.FieldParentTokenID) {
		fields = append(fields, usertoken.FieldParentTokenID)
	}
	if m.FieldCleared(usertoken.FieldCreatedAt) {
		fields = append(fields, usertoken.FieldCreatedAt)
	}
	if m.FieldCleared(usertoken.FieldRevokedAt) {
		fields = append(fields, usertoken.FieldRevokedAt)
	}
	if m.FieldCleared(usertoken.FieldLastUsedAt) {
		fields = append(fields, usertoken.FieldLastUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserTokenMutation) ClearField(name string) error {
	switch name {
	case usertoken.FieldUserID:
		m.ClearUserID()
		return nil
	case usertoken.FieldIsRevoked:
		m.ClearIsRevoked()
		return nil
	case usertoken.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case usertoken.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case usertoken.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case usertoken.FieldParentTokenID:
		m.ClearParentTokenID()
		return nil
	case usertoken.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usertoken.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case usertoken.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown UserToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserTokenMutation) ResetField(name string) error {
	switch name {
	case usertoken.FieldUserID:
		m.ResetUserID()
		return nil
	case usertoken.FieldTokenType:
		m.ResetTokenType()
		return nil
	case usertoken.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case usertoken.FieldJti:
		m.ResetJti()
		return nil
	case usertoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case usertoken.FieldIsRevoked:
		m.ResetIsRevoked()
		return nil
	case usertoken.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case usertoken.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case usertoken.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case usertoken.FieldParentTokenID:
		m.ResetParentTokenID()
		return nil
	case usertoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usertoken.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case usertoken.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown UserToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, usertoken.EdgeUser)
	}
	if m.child_user_tokens != nil {
		edges = append(edges, usertoken.EdgeChildUserTokens)
	}
	if m.parent_user_token != nil {
		edges = append(edges, usertoken.EdgeParentUserToken)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usertoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usertoken.EdgeChildUserTokens:
		ids := make([]ent.Value, 0, len(m.child_user_tokens))
		for id := range m.child_user_tokens {
			ids = append(ids, id)
		}
		return ids
	case usertoken.EdgeParentUserToken:
		if id := m.parent_user_token; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchild_user_tokens != nil {
		edges = append(edges, usertoken.EdgeChildUserTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usertoken.EdgeChildUserTokens:
		ids := make([]ent.Value, 0, len(m.removedchild_user_tokens))
		for id := range m.removedchild_user_tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, usertoken.EdgeUser)
	}
	if m.clearedchild_user_tokens {
		edges = append(edges, usertoken.EdgeChildUserTokens)
	}
	if m.clearedparent_user_token {
		edges = append(edges, usertoken.EdgeParentUserToken)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case usertoken.EdgeUser:
		return m.cleareduser
	case usertoken.EdgeChildUserTokens:
		return m.clearedchild_user_tokens
	case usertoken.EdgeParentUserToken:
		return m.clearedparent_user_token
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserTokenMutation) ClearEdge(name string) error {
	switch name {
	case usertoken.EdgeUser:
		m.ClearUser()
		return nil
	case usertoken.EdgeParentUserToken:
		m.ClearParentUserToken()
		return nil
	}
	return fmt.Errorf("unknown UserToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserTokenMutation) ResetEdge(name string) error {
	switch name {
	case usertoken.EdgeUser:
		m.ResetUser()
		return nil
	case usertoken.EdgeChildUserTokens:
		m.ResetChildUserTokens()
		return nil
	case usertoken.EdgeParentUserToken:
		m.ResetParentUserToken()
		return nil
	}
	return fmt.Errorf("unknown UserToken edge %s", name)
}
